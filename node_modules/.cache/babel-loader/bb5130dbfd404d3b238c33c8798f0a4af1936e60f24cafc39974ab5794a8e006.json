{"ast":null,"code":"import{noteFrequencies,noteFrequencyLabels,voiceFrequencies,voiceFrequencyLabels}from'./constants.js';/**\n * Output of AudioAnalysis for the frequency domain of the audio\n * @typedef {Object} AudioAnalysisOutputType\n * @property {Float32Array} values Amplitude of this frequency between {0, 1} inclusive\n * @property {number[]} frequencies Raw frequency bucket values\n * @property {string[]} labels Labels for the frequency bucket values\n *//**\n * Analyzes audio for visual output\n * @class\n */export class AudioAnalysis{/**\n   * Retrieves frequency domain data from an AnalyserNode adjusted to a decibel range\n   * returns human-readable formatting and labels\n   * @param {AnalyserNode} analyser\n   * @param {number} sampleRate\n   * @param {Float32Array} [fftResult]\n   * @param {\"frequency\"|\"music\"|\"voice\"} [analysisType]\n   * @param {number} [minDecibels] default -100\n   * @param {number} [maxDecibels] default -30\n   * @returns {AudioAnalysisOutputType}\n   */static getFrequencies(analyser,sampleRate,fftResult){let analysisType=arguments.length>3&&arguments[3]!==undefined?arguments[3]:'frequency';let minDecibels=arguments.length>4&&arguments[4]!==undefined?arguments[4]:-100;let maxDecibels=arguments.length>5&&arguments[5]!==undefined?arguments[5]:-30;if(!fftResult){fftResult=new Float32Array(analyser.frequencyBinCount);analyser.getFloatFrequencyData(fftResult);}const nyquistFrequency=sampleRate/2;const frequencyStep=1/fftResult.length*nyquistFrequency;let outputValues;let frequencies;let labels;if(analysisType==='music'||analysisType==='voice'){const useFrequencies=analysisType==='voice'?voiceFrequencies:noteFrequencies;const aggregateOutput=Array(useFrequencies.length).fill(minDecibels);for(let i=0;i<fftResult.length;i++){const frequency=i*frequencyStep;const amplitude=fftResult[i];for(let n=useFrequencies.length-1;n>=0;n--){if(frequency>useFrequencies[n]){aggregateOutput[n]=Math.max(aggregateOutput[n],amplitude);break;}}}outputValues=aggregateOutput;frequencies=analysisType==='voice'?voiceFrequencies:noteFrequencies;labels=analysisType==='voice'?voiceFrequencyLabels:noteFrequencyLabels;}else{outputValues=Array.from(fftResult);frequencies=outputValues.map((_,i)=>frequencyStep*i);labels=frequencies.map(f=>`${f.toFixed(2)} Hz`);}// We normalize to {0, 1}\nconst normalizedOutput=outputValues.map(v=>{return Math.max(0,Math.min((v-minDecibels)/(maxDecibels-minDecibels),1));});const values=new Float32Array(normalizedOutput);return{values,frequencies,labels};}/**\n   * Creates a new AudioAnalysis instance for an HTMLAudioElement\n   * @param {HTMLAudioElement} audioElement\n   * @param {AudioBuffer|null} [audioBuffer] If provided, will cache all frequency domain data from the buffer\n   * @returns {AudioAnalysis}\n   */constructor(audioElement){let audioBuffer=arguments.length>1&&arguments[1]!==undefined?arguments[1]:null;this.fftResults=[];if(audioBuffer){/**\n       * Modified from\n       * https://stackoverflow.com/questions/75063715/using-the-web-audio-api-to-analyze-a-song-without-playing\n       *\n       * We do this to populate FFT values for the audio if provided an `audioBuffer`\n       * The reason to do this is that Safari fails when using `createMediaElementSource`\n       * This has a non-zero RAM cost so we only opt-in to run it on Safari, Chrome is better\n       */const{length,sampleRate}=audioBuffer;const offlineAudioContext=new OfflineAudioContext({length,sampleRate});const source=offlineAudioContext.createBufferSource();source.buffer=audioBuffer;const analyser=offlineAudioContext.createAnalyser();analyser.fftSize=8192;analyser.smoothingTimeConstant=0.1;source.connect(analyser);// limit is :: 128 / sampleRate;\n// but we just want 60fps - cuts ~1s from 6MB to 1MB of RAM\nconst renderQuantumInSeconds=1/60;const durationInSeconds=length/sampleRate;const analyze=index=>{const suspendTime=renderQuantumInSeconds*index;if(suspendTime<durationInSeconds){offlineAudioContext.suspend(suspendTime).then(()=>{const fftResult=new Float32Array(analyser.frequencyBinCount);analyser.getFloatFrequencyData(fftResult);this.fftResults.push(fftResult);analyze(index+1);});}if(index===1){offlineAudioContext.startRendering();}else{offlineAudioContext.resume();}};source.start(0);analyze(1);this.audio=audioElement;this.context=offlineAudioContext;this.analyser=analyser;this.sampleRate=sampleRate;this.audioBuffer=audioBuffer;}else{const audioContext=new AudioContext();const track=audioContext.createMediaElementSource(audioElement);const analyser=audioContext.createAnalyser();analyser.fftSize=8192;analyser.smoothingTimeConstant=0.1;track.connect(analyser);analyser.connect(audioContext.destination);this.audio=audioElement;this.context=audioContext;this.analyser=analyser;this.sampleRate=this.context.sampleRate;this.audioBuffer=null;}}/**\n   * Gets the current frequency domain data from the playing audio track\n   * @param {\"frequency\"|\"music\"|\"voice\"} [analysisType]\n   * @param {number} [minDecibels] default -100\n   * @param {number} [maxDecibels] default -30\n   * @returns {AudioAnalysisOutputType}\n   */getFrequencies(){let analysisType=arguments.length>0&&arguments[0]!==undefined?arguments[0]:'frequency';let minDecibels=arguments.length>1&&arguments[1]!==undefined?arguments[1]:-100;let maxDecibels=arguments.length>2&&arguments[2]!==undefined?arguments[2]:-30;let fftResult=null;if(this.audioBuffer&&this.fftResults.length){const pct=this.audio.currentTime/this.audio.duration;const index=Math.min(pct*this.fftResults.length|0,this.fftResults.length-1);fftResult=this.fftResults[index];}return AudioAnalysis.getFrequencies(this.analyser,this.sampleRate,fftResult,analysisType,minDecibels,maxDecibels);}/**\n   * Resume the internal AudioContext if it was suspended due to the lack of\n   * user interaction when the AudioAnalysis was instantiated.\n   * @returns {Promise<true>}\n   */async resumeIfSuspended(){if(this.context.state==='suspended'){await this.context.resume();}return true;}}globalThis.AudioAnalysis=AudioAnalysis;","map":{"version":3,"names":["noteFrequencies","noteFrequencyLabels","voiceFrequencies","voiceFrequencyLabels","AudioAnalysis","getFrequencies","analyser","sampleRate","fftResult","analysisType","arguments","length","undefined","minDecibels","maxDecibels","Float32Array","frequencyBinCount","getFloatFrequencyData","nyquistFrequency","frequencyStep","outputValues","frequencies","labels","useFrequencies","aggregateOutput","Array","fill","i","frequency","amplitude","n","Math","max","from","map","_","f","toFixed","normalizedOutput","v","min","values","constructor","audioElement","audioBuffer","fftResults","offlineAudioContext","OfflineAudioContext","source","createBufferSource","buffer","createAnalyser","fftSize","smoothingTimeConstant","connect","renderQuantumInSeconds","durationInSeconds","analyze","index","suspendTime","suspend","then","push","startRendering","resume","start","audio","context","audioContext","AudioContext","track","createMediaElementSource","destination","pct","currentTime","duration","resumeIfSuspended","state","globalThis"],"sources":["/Users/johnpaulreju/git_dashboard/simli/simli-openai-realtime/src/lib/wavtools/lib/analysis/audio_analysis.js"],"sourcesContent":["import {\n  noteFrequencies,\n  noteFrequencyLabels,\n  voiceFrequencies,\n  voiceFrequencyLabels,\n} from './constants.js';\n\n/**\n * Output of AudioAnalysis for the frequency domain of the audio\n * @typedef {Object} AudioAnalysisOutputType\n * @property {Float32Array} values Amplitude of this frequency between {0, 1} inclusive\n * @property {number[]} frequencies Raw frequency bucket values\n * @property {string[]} labels Labels for the frequency bucket values\n */\n\n/**\n * Analyzes audio for visual output\n * @class\n */\nexport class AudioAnalysis {\n  /**\n   * Retrieves frequency domain data from an AnalyserNode adjusted to a decibel range\n   * returns human-readable formatting and labels\n   * @param {AnalyserNode} analyser\n   * @param {number} sampleRate\n   * @param {Float32Array} [fftResult]\n   * @param {\"frequency\"|\"music\"|\"voice\"} [analysisType]\n   * @param {number} [minDecibels] default -100\n   * @param {number} [maxDecibels] default -30\n   * @returns {AudioAnalysisOutputType}\n   */\n  static getFrequencies(\n    analyser,\n    sampleRate,\n    fftResult,\n    analysisType = 'frequency',\n    minDecibels = -100,\n    maxDecibels = -30,\n  ) {\n    if (!fftResult) {\n      fftResult = new Float32Array(analyser.frequencyBinCount);\n      analyser.getFloatFrequencyData(fftResult);\n    }\n    const nyquistFrequency = sampleRate / 2;\n    const frequencyStep = (1 / fftResult.length) * nyquistFrequency;\n    let outputValues;\n    let frequencies;\n    let labels;\n    if (analysisType === 'music' || analysisType === 'voice') {\n      const useFrequencies =\n        analysisType === 'voice' ? voiceFrequencies : noteFrequencies;\n      const aggregateOutput = Array(useFrequencies.length).fill(minDecibels);\n      for (let i = 0; i < fftResult.length; i++) {\n        const frequency = i * frequencyStep;\n        const amplitude = fftResult[i];\n        for (let n = useFrequencies.length - 1; n >= 0; n--) {\n          if (frequency > useFrequencies[n]) {\n            aggregateOutput[n] = Math.max(aggregateOutput[n], amplitude);\n            break;\n          }\n        }\n      }\n      outputValues = aggregateOutput;\n      frequencies =\n        analysisType === 'voice' ? voiceFrequencies : noteFrequencies;\n      labels =\n        analysisType === 'voice' ? voiceFrequencyLabels : noteFrequencyLabels;\n    } else {\n      outputValues = Array.from(fftResult);\n      frequencies = outputValues.map((_, i) => frequencyStep * i);\n      labels = frequencies.map((f) => `${f.toFixed(2)} Hz`);\n    }\n    // We normalize to {0, 1}\n    const normalizedOutput = outputValues.map((v) => {\n      return Math.max(\n        0,\n        Math.min((v - minDecibels) / (maxDecibels - minDecibels), 1),\n      );\n    });\n    const values = new Float32Array(normalizedOutput);\n    return {\n      values,\n      frequencies,\n      labels,\n    };\n  }\n\n  /**\n   * Creates a new AudioAnalysis instance for an HTMLAudioElement\n   * @param {HTMLAudioElement} audioElement\n   * @param {AudioBuffer|null} [audioBuffer] If provided, will cache all frequency domain data from the buffer\n   * @returns {AudioAnalysis}\n   */\n  constructor(audioElement, audioBuffer = null) {\n    this.fftResults = [];\n    if (audioBuffer) {\n      /**\n       * Modified from\n       * https://stackoverflow.com/questions/75063715/using-the-web-audio-api-to-analyze-a-song-without-playing\n       *\n       * We do this to populate FFT values for the audio if provided an `audioBuffer`\n       * The reason to do this is that Safari fails when using `createMediaElementSource`\n       * This has a non-zero RAM cost so we only opt-in to run it on Safari, Chrome is better\n       */\n      const { length, sampleRate } = audioBuffer;\n      const offlineAudioContext = new OfflineAudioContext({\n        length,\n        sampleRate,\n      });\n      const source = offlineAudioContext.createBufferSource();\n      source.buffer = audioBuffer;\n      const analyser = offlineAudioContext.createAnalyser();\n      analyser.fftSize = 8192;\n      analyser.smoothingTimeConstant = 0.1;\n      source.connect(analyser);\n      // limit is :: 128 / sampleRate;\n      // but we just want 60fps - cuts ~1s from 6MB to 1MB of RAM\n      const renderQuantumInSeconds = 1 / 60;\n      const durationInSeconds = length / sampleRate;\n      const analyze = (index) => {\n        const suspendTime = renderQuantumInSeconds * index;\n        if (suspendTime < durationInSeconds) {\n          offlineAudioContext.suspend(suspendTime).then(() => {\n            const fftResult = new Float32Array(analyser.frequencyBinCount);\n            analyser.getFloatFrequencyData(fftResult);\n            this.fftResults.push(fftResult);\n            analyze(index + 1);\n          });\n        }\n        if (index === 1) {\n          offlineAudioContext.startRendering();\n        } else {\n          offlineAudioContext.resume();\n        }\n      };\n      source.start(0);\n      analyze(1);\n      this.audio = audioElement;\n      this.context = offlineAudioContext;\n      this.analyser = analyser;\n      this.sampleRate = sampleRate;\n      this.audioBuffer = audioBuffer;\n    } else {\n      const audioContext = new AudioContext();\n      const track = audioContext.createMediaElementSource(audioElement);\n      const analyser = audioContext.createAnalyser();\n      analyser.fftSize = 8192;\n      analyser.smoothingTimeConstant = 0.1;\n      track.connect(analyser);\n      analyser.connect(audioContext.destination);\n      this.audio = audioElement;\n      this.context = audioContext;\n      this.analyser = analyser;\n      this.sampleRate = this.context.sampleRate;\n      this.audioBuffer = null;\n    }\n  }\n\n  /**\n   * Gets the current frequency domain data from the playing audio track\n   * @param {\"frequency\"|\"music\"|\"voice\"} [analysisType]\n   * @param {number} [minDecibels] default -100\n   * @param {number} [maxDecibels] default -30\n   * @returns {AudioAnalysisOutputType}\n   */\n  getFrequencies(\n    analysisType = 'frequency',\n    minDecibels = -100,\n    maxDecibels = -30,\n  ) {\n    let fftResult = null;\n    if (this.audioBuffer && this.fftResults.length) {\n      const pct = this.audio.currentTime / this.audio.duration;\n      const index = Math.min(\n        (pct * this.fftResults.length) | 0,\n        this.fftResults.length - 1,\n      );\n      fftResult = this.fftResults[index];\n    }\n    return AudioAnalysis.getFrequencies(\n      this.analyser,\n      this.sampleRate,\n      fftResult,\n      analysisType,\n      minDecibels,\n      maxDecibels,\n    );\n  }\n\n  /**\n   * Resume the internal AudioContext if it was suspended due to the lack of\n   * user interaction when the AudioAnalysis was instantiated.\n   * @returns {Promise<true>}\n   */\n  async resumeIfSuspended() {\n    if (this.context.state === 'suspended') {\n      await this.context.resume();\n    }\n    return true;\n  }\n}\n\nglobalThis.AudioAnalysis = AudioAnalysis;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}