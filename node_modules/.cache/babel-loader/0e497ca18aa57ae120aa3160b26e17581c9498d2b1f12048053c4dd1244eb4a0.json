{"ast":null,"code":"/**\n * EventHandler callback\n * @typedef {(event: {[key: string]: any}): void} EventHandlerCallbackType\n */const sleep=t=>new Promise(r=>setTimeout(()=>r(),t));/**\n * Inherited class for RealtimeAPI and RealtimeClient\n * Adds basic event handling\n * @class\n */export class RealtimeEventHandler{/**\n   * Create a new RealtimeEventHandler instance\n   * @returns {RealtimeEventHandler}\n   */constructor(){this.eventHandlers={};this.nextEventHandlers={};}/**\n   * Clears all event handlers\n   * @returns {true}\n   */clearEventHandlers(){this.eventHandlers={};this.nextEventHandlers={};return true;}/**\n   * Listen to specific events\n   * @param {string} eventName The name of the event to listen to\n   * @param {EventHandlerCallbackType} callback Code to execute on event\n   * @returns {EventHandlerCallbackType}\n   */on(eventName,callback){this.eventHandlers[eventName]=this.eventHandlers[eventName]||[];this.eventHandlers[eventName].push(callback);callback;}/**\n   * Listen for the next event of a specified type\n   * @param {string} eventName The name of the event to listen to\n   * @param {EventHandlerCallbackType} callback Code to execute on event\n   * @returns {EventHandlerCallbackType}\n   */onNext(eventName,callback){this.nextEventHandlers[eventName]=this.nextEventHandlers[eventName]||[];this.nextEventHandlers[eventName].push(callback);}/**\n   * Turns off event listening for specific events\n   * Calling without a callback will remove all listeners for the event\n   * @param {string} eventName\n   * @param {EventHandlerCallbackType} [callback]\n   * @returns {true}\n   */off(eventName,callback){const handlers=this.eventHandlers[eventName]||[];if(callback){const index=handlers.indexOf(callback);if(index===-1){throw new Error(`Could not turn off specified event listener for \"${eventName}\": not found as a listener`);}handlers.splice(index,1);}else{delete this.eventHandlers[eventName];}return true;}/**\n   * Turns off event listening for the next event of a specific type\n   * Calling without a callback will remove all listeners for the next event\n   * @param {string} eventName\n   * @param {EventHandlerCallbackType} [callback]\n   * @returns {true}\n   */offNext(eventName,callback){const nextHandlers=this.nextEventHandlers[eventName]||[];if(callback){const index=nextHandlers.indexOf(callback);if(index===-1){throw new Error(`Could not turn off specified next event listener for \"${eventName}\": not found as a listener`);}nextHandlers.splice(index,1);}else{delete this.nextEventHandlers[eventName];}return true;}/**\n   * Waits for next event of a specific type and returns the payload\n   * @param {string} eventName\n   * @param {number|null} [timeout]\n   * @returns {Promise<{[key: string]: any}|null>}\n   */async waitForNext(eventName){let timeout=arguments.length>1&&arguments[1]!==undefined?arguments[1]:null;const t0=Date.now();let nextEvent;this.onNext(eventName,event=>nextEvent=event);while(!nextEvent){if(timeout){const t1=Date.now();if(t1-t0>timeout){return null;}}await sleep(1);}return nextEvent;}/**\n   * Executes all events in the order they were added, with .on() event handlers executing before .onNext() handlers\n   * @param {string} eventName\n   * @param {any} event\n   * @returns {true}\n   */dispatch(eventName,event){const handlers=[].concat(this.eventHandlers[eventName]||[]);for(const handler of handlers){handler(event);}const nextHandlers=[].concat(this.nextEventHandlers[eventName]||[]);for(const nextHandler of nextHandlers){nextHandler(event);}delete this.nextEventHandlers[eventName];return true;}}","map":{"version":3,"names":["sleep","t","Promise","r","setTimeout","RealtimeEventHandler","constructor","eventHandlers","nextEventHandlers","clearEventHandlers","on","eventName","callback","push","onNext","off","handlers","index","indexOf","Error","splice","offNext","nextHandlers","waitForNext","timeout","arguments","length","undefined","t0","Date","now","nextEvent","event","t1","dispatch","concat","handler","nextHandler"],"sources":["/Users/johnpaulreju/git_dashboard/simli/simli-openai-realtime/src/lib/realtime-api-beta/lib/event_handler.js"],"sourcesContent":["/**\n * EventHandler callback\n * @typedef {(event: {[key: string]: any}): void} EventHandlerCallbackType\n */\n\nconst sleep = (t) => new Promise((r) => setTimeout(() => r(), t));\n\n/**\n * Inherited class for RealtimeAPI and RealtimeClient\n * Adds basic event handling\n * @class\n */\nexport class RealtimeEventHandler {\n  /**\n   * Create a new RealtimeEventHandler instance\n   * @returns {RealtimeEventHandler}\n   */\n  constructor() {\n    this.eventHandlers = {};\n    this.nextEventHandlers = {};\n  }\n\n  /**\n   * Clears all event handlers\n   * @returns {true}\n   */\n  clearEventHandlers() {\n    this.eventHandlers = {};\n    this.nextEventHandlers = {};\n    return true;\n  }\n\n  /**\n   * Listen to specific events\n   * @param {string} eventName The name of the event to listen to\n   * @param {EventHandlerCallbackType} callback Code to execute on event\n   * @returns {EventHandlerCallbackType}\n   */\n  on(eventName, callback) {\n    this.eventHandlers[eventName] = this.eventHandlers[eventName] || [];\n    this.eventHandlers[eventName].push(callback);\n    callback;\n  }\n\n  /**\n   * Listen for the next event of a specified type\n   * @param {string} eventName The name of the event to listen to\n   * @param {EventHandlerCallbackType} callback Code to execute on event\n   * @returns {EventHandlerCallbackType}\n   */\n  onNext(eventName, callback) {\n    this.nextEventHandlers[eventName] = this.nextEventHandlers[eventName] || [];\n    this.nextEventHandlers[eventName].push(callback);\n  }\n\n  /**\n   * Turns off event listening for specific events\n   * Calling without a callback will remove all listeners for the event\n   * @param {string} eventName\n   * @param {EventHandlerCallbackType} [callback]\n   * @returns {true}\n   */\n  off(eventName, callback) {\n    const handlers = this.eventHandlers[eventName] || [];\n    if (callback) {\n      const index = handlers.indexOf(callback);\n      if (index === -1) {\n        throw new Error(\n          `Could not turn off specified event listener for \"${eventName}\": not found as a listener`,\n        );\n      }\n      handlers.splice(index, 1);\n    } else {\n      delete this.eventHandlers[eventName];\n    }\n    return true;\n  }\n\n  /**\n   * Turns off event listening for the next event of a specific type\n   * Calling without a callback will remove all listeners for the next event\n   * @param {string} eventName\n   * @param {EventHandlerCallbackType} [callback]\n   * @returns {true}\n   */\n  offNext(eventName, callback) {\n    const nextHandlers = this.nextEventHandlers[eventName] || [];\n    if (callback) {\n      const index = nextHandlers.indexOf(callback);\n      if (index === -1) {\n        throw new Error(\n          `Could not turn off specified next event listener for \"${eventName}\": not found as a listener`,\n        );\n      }\n      nextHandlers.splice(index, 1);\n    } else {\n      delete this.nextEventHandlers[eventName];\n    }\n    return true;\n  }\n\n  /**\n   * Waits for next event of a specific type and returns the payload\n   * @param {string} eventName\n   * @param {number|null} [timeout]\n   * @returns {Promise<{[key: string]: any}|null>}\n   */\n  async waitForNext(eventName, timeout = null) {\n    const t0 = Date.now();\n    let nextEvent;\n    this.onNext(eventName, (event) => (nextEvent = event));\n    while (!nextEvent) {\n      if (timeout) {\n        const t1 = Date.now();\n        if (t1 - t0 > timeout) {\n          return null;\n        }\n      }\n      await sleep(1);\n    }\n    return nextEvent;\n  }\n\n  /**\n   * Executes all events in the order they were added, with .on() event handlers executing before .onNext() handlers\n   * @param {string} eventName\n   * @param {any} event\n   * @returns {true}\n   */\n  dispatch(eventName, event) {\n    const handlers = [].concat(this.eventHandlers[eventName] || []);\n    for (const handler of handlers) {\n      handler(event);\n    }\n    const nextHandlers = [].concat(this.nextEventHandlers[eventName] || []);\n    for (const nextHandler of nextHandlers) {\n      nextHandler(event);\n    }\n    delete this.nextEventHandlers[eventName];\n    return true;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}