{"ast":null,"code":"import{AudioProcessorSrc}from'./worklets/audio_processor.js';import{AudioAnalysis}from'./analysis/audio_analysis.js';import{WavPacker}from'./wav_packer.js';/**\n * Decodes audio into a wav file\n * @typedef {Object} DecodedAudioType\n * @property {Blob} blob\n * @property {string} url\n * @property {Float32Array} values\n * @property {AudioBuffer} audioBuffer\n *//**\n * Records live stream of user audio as PCM16 \"audio/wav\" data\n * @class\n */export class WavRecorder{/**\n   * Create a new WavRecorder instance\n   * @param {{sampleRate?: number, outputToSpeakers?: boolean, debug?: boolean}} [options]\n   * @returns {WavRecorder}\n   */constructor(){let{sampleRate=44100,outputToSpeakers=false,debug=false}=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};// Script source\nthis.scriptSrc=AudioProcessorSrc;// Config\nthis.sampleRate=sampleRate;this.outputToSpeakers=outputToSpeakers;this.debug=!!debug;this._deviceChangeCallback=null;this._devices=[];// State variables\nthis.stream=null;this.processor=null;this.source=null;this.node=null;this.recording=false;// Event handling with AudioWorklet\nthis._lastEventId=0;this.eventReceipts={};this.eventTimeout=5000;// Process chunks of audio\nthis._chunkProcessor=()=>{};this._chunkProcessorSize=void 0;this._chunkProcessorBuffer={raw:new ArrayBuffer(0),mono:new ArrayBuffer(0)};}/**\n   * Decodes audio data from multiple formats to a Blob, url, Float32Array and AudioBuffer\n   * @param {Blob|Float32Array|Int16Array|ArrayBuffer|number[]} audioData\n   * @param {number} sampleRate\n   * @param {number} fromSampleRate\n   * @returns {Promise<DecodedAudioType>}\n   */static async decode(audioData){let sampleRate=arguments.length>1&&arguments[1]!==undefined?arguments[1]:44100;let fromSampleRate=arguments.length>2&&arguments[2]!==undefined?arguments[2]:-1;const context=new AudioContext({sampleRate});let arrayBuffer;let blob;if(audioData instanceof Blob){if(fromSampleRate!==-1){throw new Error(`Can not specify \"fromSampleRate\" when reading from Blob`);}blob=audioData;arrayBuffer=await blob.arrayBuffer();}else if(audioData instanceof ArrayBuffer){if(fromSampleRate!==-1){throw new Error(`Can not specify \"fromSampleRate\" when reading from ArrayBuffer`);}arrayBuffer=audioData;blob=new Blob([arrayBuffer],{type:'audio/wav'});}else{let float32Array;let data;if(audioData instanceof Int16Array){data=audioData;float32Array=new Float32Array(audioData.length);for(let i=0;i<audioData.length;i++){float32Array[i]=audioData[i]/0x8000;}}else if(audioData instanceof Float32Array){float32Array=audioData;}else if(audioData instanceof Array){float32Array=new Float32Array(audioData);}else{throw new Error(`\"audioData\" must be one of: Blob, Float32Arrray, Int16Array, ArrayBuffer, Array<number>`);}if(fromSampleRate===-1){throw new Error(`Must specify \"fromSampleRate\" when reading from Float32Array, In16Array or Array`);}else if(fromSampleRate<3000){throw new Error(`Minimum \"fromSampleRate\" is 3000 (3kHz)`);}if(!data){data=WavPacker.floatTo16BitPCM(float32Array);}const audio={bitsPerSample:16,channels:[float32Array],data};const packer=new WavPacker();const result=packer.pack(fromSampleRate,audio);blob=result.blob;arrayBuffer=await blob.arrayBuffer();}const audioBuffer=await context.decodeAudioData(arrayBuffer);const values=audioBuffer.getChannelData(0);const url=URL.createObjectURL(blob);return{blob,url,values,audioBuffer};}/**\n   * Logs data in debug mode\n   * @param {...any} arguments\n   * @returns {true}\n   */log(){if(this.debug){this.log(...arguments);}return true;}/**\n   * Retrieves the current sampleRate for the recorder\n   * @returns {number}\n   */getSampleRate(){return this.sampleRate;}/**\n   * Retrieves the current status of the recording\n   * @returns {\"ended\"|\"paused\"|\"recording\"}\n   */getStatus(){if(!this.processor){return'ended';}else if(!this.recording){return'paused';}else{return'recording';}}/**\n   * Sends an event to the AudioWorklet\n   * @private\n   * @param {string} name\n   * @param {{[key: string]: any}} data\n   * @param {AudioWorkletNode} [_processor]\n   * @returns {Promise<{[key: string]: any}>}\n   */async _event(name){let data=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};let _processor=arguments.length>2&&arguments[2]!==undefined?arguments[2]:null;_processor=_processor||this.processor;if(!_processor){throw new Error('Can not send events without recording first');}const message={event:name,id:this._lastEventId++,data};_processor.port.postMessage(message);const t0=new Date().valueOf();while(!this.eventReceipts[message.id]){if(new Date().valueOf()-t0>this.eventTimeout){throw new Error(`Timeout waiting for \"${name}\" event`);}await new Promise(res=>setTimeout(()=>res(true),1));}const payload=this.eventReceipts[message.id];delete this.eventReceipts[message.id];return payload;}/**\n   * Sets device change callback, remove if callback provided is `null`\n   * @param {(Array<MediaDeviceInfo & {default: boolean}>): void|null} callback\n   * @returns {true}\n   */listenForDeviceChange(callback){if(callback===null&&this._deviceChangeCallback){navigator.mediaDevices.removeEventListener('devicechange',this._deviceChangeCallback);this._deviceChangeCallback=null;}else if(callback!==null){// Basically a debounce; we only want this called once when devices change\n// And we only want the most recent callback() to be executed\n// if a few are operating at the same time\nlet lastId=0;let lastDevices=[];const serializeDevices=devices=>devices.map(d=>d.deviceId).sort().join(',');const cb=async()=>{let id=++lastId;const devices=await this.listDevices();if(id===lastId){if(serializeDevices(lastDevices)!==serializeDevices(devices)){lastDevices=devices;callback(devices.slice());}}};navigator.mediaDevices.addEventListener('devicechange',cb);cb();this._deviceChangeCallback=cb;}return true;}/**\n   * Manually request permission to use the microphone\n   * @returns {Promise<true>}\n   */async requestPermission(){const permissionStatus=await navigator.permissions.query({name:'microphone'});if(permissionStatus.state==='denied'){window.alert('You must grant microphone access to use this feature.');}else if(permissionStatus.state==='prompt'){try{const stream=await navigator.mediaDevices.getUserMedia({audio:true});const tracks=stream.getTracks();tracks.forEach(track=>track.stop());}catch(e){window.alert('You must grant microphone access to use this feature.');}}return true;}/**\n   * List all eligible devices for recording, will request permission to use microphone\n   * @returns {Promise<Array<MediaDeviceInfo & {default: boolean}>>}\n   */async listDevices(){if(!navigator.mediaDevices||!('enumerateDevices'in navigator.mediaDevices)){throw new Error('Could not request user devices');}await this.requestPermission();const devices=await navigator.mediaDevices.enumerateDevices();const audioDevices=devices.filter(device=>device.kind==='audioinput');const defaultDeviceIndex=audioDevices.findIndex(device=>device.deviceId==='default');const deviceList=[];if(defaultDeviceIndex!==-1){let defaultDevice=audioDevices.splice(defaultDeviceIndex,1)[0];let existingIndex=audioDevices.findIndex(device=>device.groupId===defaultDevice.groupId);if(existingIndex!==-1){defaultDevice=audioDevices.splice(existingIndex,1)[0];}defaultDevice.default=true;deviceList.push(defaultDevice);}return deviceList.concat(audioDevices);}/**\n   * Begins a recording session and requests microphone permissions if not already granted\n   * Microphone recording indicator will appear on browser tab but status will be \"paused\"\n   * @param {string} [deviceId] if no device provided, default device will be used\n   * @returns {Promise<true>}\n   */async begin(deviceId){if(this.processor){throw new Error(`Already connected: please call .end() to start a new session`);}if(!navigator.mediaDevices||!('getUserMedia'in navigator.mediaDevices)){throw new Error('Could not request user media');}try{const config={audio:true};if(deviceId){config.audio={deviceId:{exact:deviceId}};}this.stream=await navigator.mediaDevices.getUserMedia(config);}catch(err){throw new Error('Could not start media stream');}const context=new AudioContext({sampleRate:this.sampleRate});const source=context.createMediaStreamSource(this.stream);// Load and execute the module script.\ntry{await context.audioWorklet.addModule(this.scriptSrc);}catch(e){console.error(e);throw new Error(`Could not add audioWorklet module: ${this.scriptSrc}`);}const processor=new AudioWorkletNode(context,'audio_processor');processor.port.onmessage=e=>{const{event,id,data}=e.data;if(event==='receipt'){this.eventReceipts[id]=data;}else if(event==='chunk'){if(this._chunkProcessorSize){const buffer=this._chunkProcessorBuffer;this._chunkProcessorBuffer={raw:WavPacker.mergeBuffers(buffer.raw,data.raw),mono:WavPacker.mergeBuffers(buffer.mono,data.mono)};if(this._chunkProcessorBuffer.mono.byteLength>=this._chunkProcessorSize){this._chunkProcessor(this._chunkProcessorBuffer);this._chunkProcessorBuffer={raw:new ArrayBuffer(0),mono:new ArrayBuffer(0)};}}else{this._chunkProcessor(data);}}};const node=source.connect(processor);const analyser=context.createAnalyser();analyser.fftSize=8192;analyser.smoothingTimeConstant=0.1;node.connect(analyser);if(this.outputToSpeakers){// eslint-disable-next-line no-console\nconsole.warn('Warning: Output to speakers may affect sound quality,\\n'+'especially due to system audio feedback preventative measures.\\n'+'use only for debugging');analyser.connect(context.destination);}this.source=source;this.node=node;this.analyser=analyser;this.processor=processor;return true;}/**\n   * Gets the current frequency domain data from the recording track\n   * @param {\"frequency\"|\"music\"|\"voice\"} [analysisType]\n   * @param {number} [minDecibels] default -100\n   * @param {number} [maxDecibels] default -30\n   * @returns {import('./analysis/audio_analysis.js').AudioAnalysisOutputType}\n   */getFrequencies(){let analysisType=arguments.length>0&&arguments[0]!==undefined?arguments[0]:'frequency';let minDecibels=arguments.length>1&&arguments[1]!==undefined?arguments[1]:-100;let maxDecibels=arguments.length>2&&arguments[2]!==undefined?arguments[2]:-30;if(!this.processor){throw new Error('Session ended: please call .begin() first');}return AudioAnalysis.getFrequencies(this.analyser,this.sampleRate,null,analysisType,minDecibels,maxDecibels);}/**\n   * Pauses the recording\n   * Keeps microphone stream open but halts storage of audio\n   * @returns {Promise<true>}\n   */async pause(){if(!this.processor){throw new Error('Session ended: please call .begin() first');}else if(!this.recording){throw new Error('Already paused: please call .record() first');}if(this._chunkProcessorBuffer.raw.byteLength){this._chunkProcessor(this._chunkProcessorBuffer);}this.log('Pausing ...');await this._event('stop');this.recording=false;return true;}/**\n   * Start recording stream and storing to memory from the connected audio source\n   * @param {(data: { mono: Int16Array; raw: Int16Array }) => any} [chunkProcessor]\n   * @param {number} [chunkSize] chunkProcessor will not be triggered until this size threshold met in mono audio\n   * @returns {Promise<true>}\n   */async record(){let chunkProcessor=arguments.length>0&&arguments[0]!==undefined?arguments[0]:()=>{};let chunkSize=arguments.length>1&&arguments[1]!==undefined?arguments[1]:8192;if(!this.processor){throw new Error('Session ended: please call .begin() first');}else if(this.recording){throw new Error('Already recording: please call .pause() first');}else if(typeof chunkProcessor!=='function'){throw new Error(`chunkProcessor must be a function`);}this._chunkProcessor=chunkProcessor;this._chunkProcessorSize=chunkSize;this._chunkProcessorBuffer={raw:new ArrayBuffer(0),mono:new ArrayBuffer(0)};this.log('Recording ...');await this._event('start');this.recording=true;return true;}/**\n   * Clears the audio buffer, empties stored recording\n   * @returns {Promise<true>}\n   */async clear(){if(!this.processor){throw new Error('Session ended: please call .begin() first');}await this._event('clear');return true;}/**\n   * Reads the current audio stream data\n   * @returns {Promise<{meanValues: Float32Array, channels: Array<Float32Array>}>}\n   */async read(){if(!this.processor){throw new Error('Session ended: please call .begin() first');}this.log('Reading ...');const result=await this._event('read');return result;}/**\n   * Saves the current audio stream to a file\n   * @param {boolean} [force] Force saving while still recording\n   * @returns {Promise<import('./wav_packer.js').WavPackerAudioType>}\n   */async save(){let force=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;if(!this.processor){throw new Error('Session ended: please call .begin() first');}if(!force&&this.recording){throw new Error('Currently recording: please call .pause() first, or call .save(true) to force');}this.log('Exporting ...');const exportData=await this._event('export');const packer=new WavPacker();const result=packer.pack(this.sampleRate,exportData.audio);return result;}/**\n   * Ends the current recording session and saves the result\n   * @returns {Promise<import('./wav_packer.js').WavPackerAudioType>}\n   */async end(){if(!this.processor){throw new Error('Session ended: please call .begin() first');}const _processor=this.processor;this.log('Stopping ...');await this._event('stop');this.recording=false;const tracks=this.stream.getTracks();tracks.forEach(track=>track.stop());this.log('Exporting ...');const exportData=await this._event('export',{},_processor);this.processor.disconnect();this.source.disconnect();this.node.disconnect();this.analyser.disconnect();this.stream=null;this.processor=null;this.source=null;this.node=null;const packer=new WavPacker();const result=packer.pack(this.sampleRate,exportData.audio);return result;}/**\n   * Performs a full cleanup of WavRecorder instance\n   * Stops actively listening via microphone and removes existing listeners\n   * @returns {Promise<true>}\n   */async quit(){this.listenForDeviceChange(null);if(this.processor){await this.end();}return true;}}globalThis.WavRecorder=WavRecorder;","map":{"version":3,"names":["AudioProcessorSrc","AudioAnalysis","WavPacker","WavRecorder","constructor","sampleRate","outputToSpeakers","debug","arguments","length","undefined","scriptSrc","_deviceChangeCallback","_devices","stream","processor","source","node","recording","_lastEventId","eventReceipts","eventTimeout","_chunkProcessor","_chunkProcessorSize","_chunkProcessorBuffer","raw","ArrayBuffer","mono","decode","audioData","fromSampleRate","context","AudioContext","arrayBuffer","blob","Blob","Error","type","float32Array","data","Int16Array","Float32Array","i","Array","floatTo16BitPCM","audio","bitsPerSample","channels","packer","result","pack","audioBuffer","decodeAudioData","values","getChannelData","url","URL","createObjectURL","log","getSampleRate","getStatus","_event","name","_processor","message","event","id","port","postMessage","t0","Date","valueOf","Promise","res","setTimeout","payload","listenForDeviceChange","callback","navigator","mediaDevices","removeEventListener","lastId","lastDevices","serializeDevices","devices","map","d","deviceId","sort","join","cb","listDevices","slice","addEventListener","requestPermission","permissionStatus","permissions","query","state","window","alert","getUserMedia","tracks","getTracks","forEach","track","stop","e","enumerateDevices","audioDevices","filter","device","kind","defaultDeviceIndex","findIndex","deviceList","defaultDevice","splice","existingIndex","groupId","default","push","concat","begin","config","exact","err","createMediaStreamSource","audioWorklet","addModule","console","error","AudioWorkletNode","onmessage","buffer","mergeBuffers","byteLength","connect","analyser","createAnalyser","fftSize","smoothingTimeConstant","warn","destination","getFrequencies","analysisType","minDecibels","maxDecibels","pause","record","chunkProcessor","chunkSize","clear","read","save","force","exportData","end","disconnect","quit","globalThis"],"sources":["/Users/johnpaulreju/git_dashboard/simli/simli-openai-realtime/src/lib/wavtools/lib/wav_recorder.js"],"sourcesContent":["import { AudioProcessorSrc } from './worklets/audio_processor.js';\nimport { AudioAnalysis } from './analysis/audio_analysis.js';\nimport { WavPacker } from './wav_packer.js';\n\n/**\n * Decodes audio into a wav file\n * @typedef {Object} DecodedAudioType\n * @property {Blob} blob\n * @property {string} url\n * @property {Float32Array} values\n * @property {AudioBuffer} audioBuffer\n */\n\n/**\n * Records live stream of user audio as PCM16 \"audio/wav\" data\n * @class\n */\nexport class WavRecorder {\n  /**\n   * Create a new WavRecorder instance\n   * @param {{sampleRate?: number, outputToSpeakers?: boolean, debug?: boolean}} [options]\n   * @returns {WavRecorder}\n   */\n  constructor({\n    sampleRate = 44100,\n    outputToSpeakers = false,\n    debug = false,\n  } = {}) {\n    // Script source\n    this.scriptSrc = AudioProcessorSrc;\n    // Config\n    this.sampleRate = sampleRate;\n    this.outputToSpeakers = outputToSpeakers;\n    this.debug = !!debug;\n    this._deviceChangeCallback = null;\n    this._devices = [];\n    // State variables\n    this.stream = null;\n    this.processor = null;\n    this.source = null;\n    this.node = null;\n    this.recording = false;\n    // Event handling with AudioWorklet\n    this._lastEventId = 0;\n    this.eventReceipts = {};\n    this.eventTimeout = 5000;\n    // Process chunks of audio\n    this._chunkProcessor = () => {};\n    this._chunkProcessorSize = void 0;\n    this._chunkProcessorBuffer = {\n      raw: new ArrayBuffer(0),\n      mono: new ArrayBuffer(0),\n    };\n  }\n\n  /**\n   * Decodes audio data from multiple formats to a Blob, url, Float32Array and AudioBuffer\n   * @param {Blob|Float32Array|Int16Array|ArrayBuffer|number[]} audioData\n   * @param {number} sampleRate\n   * @param {number} fromSampleRate\n   * @returns {Promise<DecodedAudioType>}\n   */\n  static async decode(audioData, sampleRate = 44100, fromSampleRate = -1) {\n    const context = new AudioContext({ sampleRate });\n    let arrayBuffer;\n    let blob;\n    if (audioData instanceof Blob) {\n      if (fromSampleRate !== -1) {\n        throw new Error(\n          `Can not specify \"fromSampleRate\" when reading from Blob`,\n        );\n      }\n      blob = audioData;\n      arrayBuffer = await blob.arrayBuffer();\n    } else if (audioData instanceof ArrayBuffer) {\n      if (fromSampleRate !== -1) {\n        throw new Error(\n          `Can not specify \"fromSampleRate\" when reading from ArrayBuffer`,\n        );\n      }\n      arrayBuffer = audioData;\n      blob = new Blob([arrayBuffer], { type: 'audio/wav' });\n    } else {\n      let float32Array;\n      let data;\n      if (audioData instanceof Int16Array) {\n        data = audioData;\n        float32Array = new Float32Array(audioData.length);\n        for (let i = 0; i < audioData.length; i++) {\n          float32Array[i] = audioData[i] / 0x8000;\n        }\n      } else if (audioData instanceof Float32Array) {\n        float32Array = audioData;\n      } else if (audioData instanceof Array) {\n        float32Array = new Float32Array(audioData);\n      } else {\n        throw new Error(\n          `\"audioData\" must be one of: Blob, Float32Arrray, Int16Array, ArrayBuffer, Array<number>`,\n        );\n      }\n      if (fromSampleRate === -1) {\n        throw new Error(\n          `Must specify \"fromSampleRate\" when reading from Float32Array, In16Array or Array`,\n        );\n      } else if (fromSampleRate < 3000) {\n        throw new Error(`Minimum \"fromSampleRate\" is 3000 (3kHz)`);\n      }\n      if (!data) {\n        data = WavPacker.floatTo16BitPCM(float32Array);\n      }\n      const audio = {\n        bitsPerSample: 16,\n        channels: [float32Array],\n        data,\n      };\n      const packer = new WavPacker();\n      const result = packer.pack(fromSampleRate, audio);\n      blob = result.blob;\n      arrayBuffer = await blob.arrayBuffer();\n    }\n    const audioBuffer = await context.decodeAudioData(arrayBuffer);\n    const values = audioBuffer.getChannelData(0);\n    const url = URL.createObjectURL(blob);\n    return {\n      blob,\n      url,\n      values,\n      audioBuffer,\n    };\n  }\n\n  /**\n   * Logs data in debug mode\n   * @param {...any} arguments\n   * @returns {true}\n   */\n  log() {\n    if (this.debug) {\n      this.log(...arguments);\n    }\n    return true;\n  }\n\n  /**\n   * Retrieves the current sampleRate for the recorder\n   * @returns {number}\n   */\n  getSampleRate() {\n    return this.sampleRate;\n  }\n\n  /**\n   * Retrieves the current status of the recording\n   * @returns {\"ended\"|\"paused\"|\"recording\"}\n   */\n  getStatus() {\n    if (!this.processor) {\n      return 'ended';\n    } else if (!this.recording) {\n      return 'paused';\n    } else {\n      return 'recording';\n    }\n  }\n\n  /**\n   * Sends an event to the AudioWorklet\n   * @private\n   * @param {string} name\n   * @param {{[key: string]: any}} data\n   * @param {AudioWorkletNode} [_processor]\n   * @returns {Promise<{[key: string]: any}>}\n   */\n  async _event(name, data = {}, _processor = null) {\n    _processor = _processor || this.processor;\n    if (!_processor) {\n      throw new Error('Can not send events without recording first');\n    }\n    const message = {\n      event: name,\n      id: this._lastEventId++,\n      data,\n    };\n    _processor.port.postMessage(message);\n    const t0 = new Date().valueOf();\n    while (!this.eventReceipts[message.id]) {\n      if (new Date().valueOf() - t0 > this.eventTimeout) {\n        throw new Error(`Timeout waiting for \"${name}\" event`);\n      }\n      await new Promise((res) => setTimeout(() => res(true), 1));\n    }\n    const payload = this.eventReceipts[message.id];\n    delete this.eventReceipts[message.id];\n    return payload;\n  }\n\n  /**\n   * Sets device change callback, remove if callback provided is `null`\n   * @param {(Array<MediaDeviceInfo & {default: boolean}>): void|null} callback\n   * @returns {true}\n   */\n  listenForDeviceChange(callback) {\n    if (callback === null && this._deviceChangeCallback) {\n      navigator.mediaDevices.removeEventListener(\n        'devicechange',\n        this._deviceChangeCallback,\n      );\n      this._deviceChangeCallback = null;\n    } else if (callback !== null) {\n      // Basically a debounce; we only want this called once when devices change\n      // And we only want the most recent callback() to be executed\n      // if a few are operating at the same time\n      let lastId = 0;\n      let lastDevices = [];\n      const serializeDevices = (devices) =>\n        devices\n          .map((d) => d.deviceId)\n          .sort()\n          .join(',');\n      const cb = async () => {\n        let id = ++lastId;\n        const devices = await this.listDevices();\n        if (id === lastId) {\n          if (serializeDevices(lastDevices) !== serializeDevices(devices)) {\n            lastDevices = devices;\n            callback(devices.slice());\n          }\n        }\n      };\n      navigator.mediaDevices.addEventListener('devicechange', cb);\n      cb();\n      this._deviceChangeCallback = cb;\n    }\n    return true;\n  }\n\n  /**\n   * Manually request permission to use the microphone\n   * @returns {Promise<true>}\n   */\n  async requestPermission() {\n    const permissionStatus = await navigator.permissions.query({\n      name: 'microphone',\n    });\n    if (permissionStatus.state === 'denied') {\n      window.alert('You must grant microphone access to use this feature.');\n    } else if (permissionStatus.state === 'prompt') {\n      try {\n        const stream = await navigator.mediaDevices.getUserMedia({\n          audio: true,\n        });\n        const tracks = stream.getTracks();\n        tracks.forEach((track) => track.stop());\n      } catch (e) {\n        window.alert('You must grant microphone access to use this feature.');\n      }\n    }\n    return true;\n  }\n\n  /**\n   * List all eligible devices for recording, will request permission to use microphone\n   * @returns {Promise<Array<MediaDeviceInfo & {default: boolean}>>}\n   */\n  async listDevices() {\n    if (\n      !navigator.mediaDevices ||\n      !('enumerateDevices' in navigator.mediaDevices)\n    ) {\n      throw new Error('Could not request user devices');\n    }\n    await this.requestPermission();\n    const devices = await navigator.mediaDevices.enumerateDevices();\n    const audioDevices = devices.filter(\n      (device) => device.kind === 'audioinput',\n    );\n    const defaultDeviceIndex = audioDevices.findIndex(\n      (device) => device.deviceId === 'default',\n    );\n    const deviceList = [];\n    if (defaultDeviceIndex !== -1) {\n      let defaultDevice = audioDevices.splice(defaultDeviceIndex, 1)[0];\n      let existingIndex = audioDevices.findIndex(\n        (device) => device.groupId === defaultDevice.groupId,\n      );\n      if (existingIndex !== -1) {\n        defaultDevice = audioDevices.splice(existingIndex, 1)[0];\n      }\n      defaultDevice.default = true;\n      deviceList.push(defaultDevice);\n    }\n    return deviceList.concat(audioDevices);\n  }\n\n  /**\n   * Begins a recording session and requests microphone permissions if not already granted\n   * Microphone recording indicator will appear on browser tab but status will be \"paused\"\n   * @param {string} [deviceId] if no device provided, default device will be used\n   * @returns {Promise<true>}\n   */\n  async begin(deviceId) {\n    if (this.processor) {\n      throw new Error(\n        `Already connected: please call .end() to start a new session`,\n      );\n    }\n\n    if (\n      !navigator.mediaDevices ||\n      !('getUserMedia' in navigator.mediaDevices)\n    ) {\n      throw new Error('Could not request user media');\n    }\n    try {\n      const config = { audio: true };\n      if (deviceId) {\n        config.audio = { deviceId: { exact: deviceId } };\n      }\n      this.stream = await navigator.mediaDevices.getUserMedia(config);\n    } catch (err) {\n      throw new Error('Could not start media stream');\n    }\n\n    const context = new AudioContext({ sampleRate: this.sampleRate });\n    const source = context.createMediaStreamSource(this.stream);\n    // Load and execute the module script.\n    try {\n      await context.audioWorklet.addModule(this.scriptSrc);\n    } catch (e) {\n      console.error(e);\n      throw new Error(`Could not add audioWorklet module: ${this.scriptSrc}`);\n    }\n    const processor = new AudioWorkletNode(context, 'audio_processor');\n    processor.port.onmessage = (e) => {\n      const { event, id, data } = e.data;\n      if (event === 'receipt') {\n        this.eventReceipts[id] = data;\n      } else if (event === 'chunk') {\n        if (this._chunkProcessorSize) {\n          const buffer = this._chunkProcessorBuffer;\n          this._chunkProcessorBuffer = {\n            raw: WavPacker.mergeBuffers(buffer.raw, data.raw),\n            mono: WavPacker.mergeBuffers(buffer.mono, data.mono),\n          };\n          if (\n            this._chunkProcessorBuffer.mono.byteLength >=\n            this._chunkProcessorSize\n          ) {\n            this._chunkProcessor(this._chunkProcessorBuffer);\n            this._chunkProcessorBuffer = {\n              raw: new ArrayBuffer(0),\n              mono: new ArrayBuffer(0),\n            };\n          }\n        } else {\n          this._chunkProcessor(data);\n        }\n      }\n    };\n\n    const node = source.connect(processor);\n    const analyser = context.createAnalyser();\n    analyser.fftSize = 8192;\n    analyser.smoothingTimeConstant = 0.1;\n    node.connect(analyser);\n    if (this.outputToSpeakers) {\n      // eslint-disable-next-line no-console\n      console.warn(\n        'Warning: Output to speakers may affect sound quality,\\n' +\n          'especially due to system audio feedback preventative measures.\\n' +\n          'use only for debugging',\n      );\n      analyser.connect(context.destination);\n    }\n\n    this.source = source;\n    this.node = node;\n    this.analyser = analyser;\n    this.processor = processor;\n    return true;\n  }\n\n  /**\n   * Gets the current frequency domain data from the recording track\n   * @param {\"frequency\"|\"music\"|\"voice\"} [analysisType]\n   * @param {number} [minDecibels] default -100\n   * @param {number} [maxDecibels] default -30\n   * @returns {import('./analysis/audio_analysis.js').AudioAnalysisOutputType}\n   */\n  getFrequencies(\n    analysisType = 'frequency',\n    minDecibels = -100,\n    maxDecibels = -30,\n  ) {\n    if (!this.processor) {\n      throw new Error('Session ended: please call .begin() first');\n    }\n    return AudioAnalysis.getFrequencies(\n      this.analyser,\n      this.sampleRate,\n      null,\n      analysisType,\n      minDecibels,\n      maxDecibels,\n    );\n  }\n\n  /**\n   * Pauses the recording\n   * Keeps microphone stream open but halts storage of audio\n   * @returns {Promise<true>}\n   */\n  async pause() {\n    if (!this.processor) {\n      throw new Error('Session ended: please call .begin() first');\n    } else if (!this.recording) {\n      throw new Error('Already paused: please call .record() first');\n    }\n    if (this._chunkProcessorBuffer.raw.byteLength) {\n      this._chunkProcessor(this._chunkProcessorBuffer);\n    }\n    this.log('Pausing ...');\n    await this._event('stop');\n    this.recording = false;\n    return true;\n  }\n\n  /**\n   * Start recording stream and storing to memory from the connected audio source\n   * @param {(data: { mono: Int16Array; raw: Int16Array }) => any} [chunkProcessor]\n   * @param {number} [chunkSize] chunkProcessor will not be triggered until this size threshold met in mono audio\n   * @returns {Promise<true>}\n   */\n  async record(chunkProcessor = () => {}, chunkSize = 8192) {\n    if (!this.processor) {\n      throw new Error('Session ended: please call .begin() first');\n    } else if (this.recording) {\n      throw new Error('Already recording: please call .pause() first');\n    } else if (typeof chunkProcessor !== 'function') {\n      throw new Error(`chunkProcessor must be a function`);\n    }\n    this._chunkProcessor = chunkProcessor;\n    this._chunkProcessorSize = chunkSize;\n    this._chunkProcessorBuffer = {\n      raw: new ArrayBuffer(0),\n      mono: new ArrayBuffer(0),\n    };\n    this.log('Recording ...');\n    await this._event('start');\n    this.recording = true;\n    return true;\n  }\n\n  /**\n   * Clears the audio buffer, empties stored recording\n   * @returns {Promise<true>}\n   */\n  async clear() {\n    if (!this.processor) {\n      throw new Error('Session ended: please call .begin() first');\n    }\n    await this._event('clear');\n    return true;\n  }\n\n  /**\n   * Reads the current audio stream data\n   * @returns {Promise<{meanValues: Float32Array, channels: Array<Float32Array>}>}\n   */\n  async read() {\n    if (!this.processor) {\n      throw new Error('Session ended: please call .begin() first');\n    }\n    this.log('Reading ...');\n    const result = await this._event('read');\n    return result;\n  }\n\n  /**\n   * Saves the current audio stream to a file\n   * @param {boolean} [force] Force saving while still recording\n   * @returns {Promise<import('./wav_packer.js').WavPackerAudioType>}\n   */\n  async save(force = false) {\n    if (!this.processor) {\n      throw new Error('Session ended: please call .begin() first');\n    }\n    if (!force && this.recording) {\n      throw new Error(\n        'Currently recording: please call .pause() first, or call .save(true) to force',\n      );\n    }\n    this.log('Exporting ...');\n    const exportData = await this._event('export');\n    const packer = new WavPacker();\n    const result = packer.pack(this.sampleRate, exportData.audio);\n    return result;\n  }\n\n  /**\n   * Ends the current recording session and saves the result\n   * @returns {Promise<import('./wav_packer.js').WavPackerAudioType>}\n   */\n  async end() {\n    if (!this.processor) {\n      throw new Error('Session ended: please call .begin() first');\n    }\n\n    const _processor = this.processor;\n\n    this.log('Stopping ...');\n    await this._event('stop');\n    this.recording = false;\n    const tracks = this.stream.getTracks();\n    tracks.forEach((track) => track.stop());\n\n    this.log('Exporting ...');\n    const exportData = await this._event('export', {}, _processor);\n\n    this.processor.disconnect();\n    this.source.disconnect();\n    this.node.disconnect();\n    this.analyser.disconnect();\n    this.stream = null;\n    this.processor = null;\n    this.source = null;\n    this.node = null;\n\n    const packer = new WavPacker();\n    const result = packer.pack(this.sampleRate, exportData.audio);\n    return result;\n  }\n\n  /**\n   * Performs a full cleanup of WavRecorder instance\n   * Stops actively listening via microphone and removes existing listeners\n   * @returns {Promise<true>}\n   */\n  async quit() {\n    this.listenForDeviceChange(null);\n    if (this.processor) {\n      await this.end();\n    }\n    return true;\n  }\n}\n\nglobalThis.WavRecorder = WavRecorder;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}