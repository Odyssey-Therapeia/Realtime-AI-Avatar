{"ast":null,"code":"import{RealtimeUtils}from'./utils.js';/**\n * Contains text and audio information about a item\n * Can also be used as a delta\n * @typedef {Object} ItemContentDeltaType\n * @property {string} [text]\n * @property {Int16Array} [audio]\n * @property {string} [arguments]\n * @property {string} [transcript]\n *//**\n * RealtimeConversation holds conversation history\n * and performs event validation for RealtimeAPI\n * @class\n */export class RealtimeConversation{/**\n   * Create a new RealtimeConversation instance\n   * @returns {RealtimeConversation}\n   */constructor(){this.defaultFrequency=24000;// 24,000 Hz\nthis.EventProcessors={'conversation.item.created':event=>{const{item}=event;// deep copy values\nconst newItem=JSON.parse(JSON.stringify(item));if(!this.itemLookup[newItem.id]){this.itemLookup[newItem.id]=newItem;this.items.push(newItem);}newItem.formatted={};newItem.formatted.audio=new Int16Array(0);newItem.formatted.text='';newItem.formatted.transcript='';// If we have a speech item, can populate audio\nif(this.queuedSpeechItems[newItem.id]){newItem.formatted.audio=this.queuedSpeechItems[newItem.id].audio;delete this.queuedSpeechItems[newItem.id];// free up some memory\n}// Populate formatted text if it comes out on creation\nif(newItem.content){const textContent=newItem.content.filter(c=>['text','input_text'].includes(c.type));for(const content of textContent){newItem.formatted.text+=content.text;}}// If we have a transcript item, can pre-populate transcript\nif(this.queuedTranscriptItems[newItem.id]){newItem.formatted.transcript=this.queuedTranscriptItems.transcript;delete this.queuedTranscriptItems[newItem.id];}if(newItem.type==='message'){if(newItem.role==='user'){newItem.status='completed';if(this.queuedInputAudio){newItem.formatted.audio=this.queuedInputAudio;this.queuedInputAudio=null;}}else{newItem.status='in_progress';}}else if(newItem.type==='function_call'){newItem.formatted.tool={type:'function',name:newItem.name,call_id:newItem.call_id,arguments:''};newItem.status='in_progress';}else if(newItem.type==='function_call_output'){newItem.status='completed';newItem.formatted.output=newItem.output;}return{item:newItem,delta:null};},'conversation.item.truncated':event=>{const{item_id,audio_end_ms}=event;const item=this.itemLookup[item_id];if(!item){throw new Error(`item.truncated: Item \"${item_id}\" not found`);}const endIndex=Math.floor(audio_end_ms*this.defaultFrequency/1000);item.formatted.transcript='';item.formatted.audio=item.formatted.audio.slice(0,endIndex);return{item,delta:null};},'conversation.item.deleted':event=>{const{item_id}=event;const item=this.itemLookup[item_id];if(!item){throw new Error(`item.deleted: Item \"${item_id}\" not found`);}delete this.itemLookup[item.id];const index=this.items.indexOf(item);if(index>-1){this.items.splice(index,1);}return{item,delta:null};},'conversation.item.input_audio_transcription.completed':event=>{const{item_id,content_index,transcript}=event;const item=this.itemLookup[item_id];// We use a single space to represent an empty transcript for .formatted values\n// Otherwise it looks like no transcript provided\nconst formattedTranscript=transcript||' ';if(!item){// We can receive transcripts in VAD mode before item.created\n// This happens specifically when audio is empty\nthis.queuedTranscriptItems[item_id]={transcript:formattedTranscript};return{item:null,delta:null};}else{item.content[content_index].transcript=transcript;item.formatted.transcript=formattedTranscript;return{item,delta:{transcript}};}},'input_audio_buffer.speech_started':event=>{const{item_id,audio_start_ms}=event;this.queuedSpeechItems[item_id]={audio_start_ms};return{item:null,delta:null};},'input_audio_buffer.speech_stopped':(event,inputAudioBuffer)=>{const{item_id,audio_end_ms}=event;const speech=this.queuedSpeechItems[item_id];speech.audio_end_ms=audio_end_ms;if(inputAudioBuffer){const startIndex=Math.floor(speech.audio_start_ms*this.defaultFrequency/1000);const endIndex=Math.floor(speech.audio_end_ms*this.defaultFrequency/1000);speech.audio=inputAudioBuffer.slice(startIndex,endIndex);}return{item:null,delta:null};},'response.created':event=>{const{response}=event;if(!this.responseLookup[response.id]){this.responseLookup[response.id]=response;this.responses.push(response);}return{item:null,delta:null};},'response.output_item.added':event=>{const{response_id,item}=event;const response=this.responseLookup[response_id];if(!response){throw new Error(`response.output_item.added: Response \"${response_id}\" not found`);}response.output.push(item.id);return{item:null,delta:null};},'response.output_item.done':event=>{const{item}=event;if(!item){throw new Error(`response.output_item.done: Missing \"item\"`);}const foundItem=this.itemLookup[item.id];if(!foundItem){throw new Error(`response.output_item.done: Item \"${item.id}\" not found`);}foundItem.status=item.status;return{item:foundItem,delta:null};},'response.content_part.added':event=>{const{item_id,part}=event;const item=this.itemLookup[item_id];if(!item){throw new Error(`response.content_part.added: Item \"${item_id}\" not found`);}item.content.push(part);return{item,delta:null};},'response.audio_transcript.delta':event=>{const{item_id,content_index,delta}=event;const item=this.itemLookup[item_id];if(!item){throw new Error(`response.audio_transcript.delta: Item \"${item_id}\" not found`);}item.content[content_index].transcript+=delta;item.formatted.transcript+=delta;return{item,delta:{transcript:delta}};},'response.audio.delta':event=>{const{item_id,content_index,delta}=event;const item=this.itemLookup[item_id];if(!item){throw new Error(`response.audio.delta: Item \"${item_id}\" not found`);}// This never gets renderered, we care about the file data instead\n// item.content[content_index].audio += delta;\nconst arrayBuffer=RealtimeUtils.base64ToArrayBuffer(delta);const appendValues=new Int16Array(arrayBuffer);item.formatted.audio=RealtimeUtils.mergeInt16Arrays(item.formatted.audio,appendValues);return{item,delta:{audio:appendValues}};},'response.text.delta':event=>{const{item_id,content_index,delta}=event;const item=this.itemLookup[item_id];if(!item){throw new Error(`response.text.delta: Item \"${item_id}\" not found`);}item.content[content_index].text+=delta;item.formatted.text+=delta;return{item,delta:{text:delta}};},'response.function_call_arguments.delta':event=>{const{item_id,delta}=event;const item=this.itemLookup[item_id];if(!item){throw new Error(`response.function_call_arguments.delta: Item \"${item_id}\" not found`);}item.arguments+=delta;item.formatted.tool.arguments+=delta;return{item,delta:{arguments:delta}};}};this.clear();}/**\n   * Clears the conversation history and resets to default\n   * @returns {true}\n   */clear(){this.itemLookup={};this.items=[];this.responseLookup={};this.responses=[];this.queuedSpeechItems={};this.queuedTranscriptItems={};this.queuedInputAudio=null;return true;}/**\n   * Queue input audio for manual speech event\n   * @param {Int16Array} inputAudio\n   * @returns {Int16Array}\n   */queueInputAudio(inputAudio){this.queuedInputAudio=inputAudio;return inputAudio;}/**\n   * Process an event from the WebSocket server and compose items\n   * @param {Object} event\n   * @param  {...any} args\n   * @returns {item: import('./client.js').ItemType | null, delta: ItemContentDeltaType | null}\n   */processEvent(event){if(!event.event_id){console.error(event);throw new Error(`Missing \"event_id\" on event`);}if(!event.type){console.error(event);throw new Error(`Missing \"type\" on event`);}const eventProcessor=this.EventProcessors[event.type];if(!eventProcessor){throw new Error(`Missing conversation event processor for \"${event.type}\"`);}for(var _len=arguments.length,args=new Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){args[_key-1]=arguments[_key];}return eventProcessor.call(this,event,...args);}/**\n   * Retrieves a item by id\n   * @param {string} id\n   * @returns {import('./client.js').ItemType}\n   */getItem(id){return this.itemLookup[id]||null;}/**\n   * Retrieves all items in the conversation\n   * @returns {import('./client.js').ItemType[]}\n   */getItems(){return this.items.slice();}}","map":{"version":3,"names":["RealtimeUtils","RealtimeConversation","constructor","defaultFrequency","EventProcessors","event","item","newItem","JSON","parse","stringify","itemLookup","id","items","push","formatted","audio","Int16Array","text","transcript","queuedSpeechItems","content","textContent","filter","c","includes","type","queuedTranscriptItems","role","status","queuedInputAudio","tool","name","call_id","arguments","output","delta","item_id","audio_end_ms","Error","endIndex","Math","floor","slice","index","indexOf","splice","content_index","formattedTranscript","audio_start_ms","input_audio_buffer.speech_stopped","inputAudioBuffer","speech","startIndex","response","responseLookup","responses","response_id","foundItem","part","arrayBuffer","base64ToArrayBuffer","appendValues","mergeInt16Arrays","clear","queueInputAudio","inputAudio","processEvent","event_id","console","error","eventProcessor","_len","length","args","Array","_key","call","getItem","getItems"],"sources":["/Users/johnpaulreju/git_dashboard/simli/simli-openai-realtime/src/lib/realtime-api-beta/lib/conversation.js"],"sourcesContent":["import { RealtimeUtils } from './utils.js';\n\n/**\n * Contains text and audio information about a item\n * Can also be used as a delta\n * @typedef {Object} ItemContentDeltaType\n * @property {string} [text]\n * @property {Int16Array} [audio]\n * @property {string} [arguments]\n * @property {string} [transcript]\n */\n\n/**\n * RealtimeConversation holds conversation history\n * and performs event validation for RealtimeAPI\n * @class\n */\nexport class RealtimeConversation {\n  defaultFrequency = 24_000; // 24,000 Hz\n\n  EventProcessors = {\n    'conversation.item.created': (event) => {\n      const { item } = event;\n      // deep copy values\n      const newItem = JSON.parse(JSON.stringify(item));\n      if (!this.itemLookup[newItem.id]) {\n        this.itemLookup[newItem.id] = newItem;\n        this.items.push(newItem);\n      }\n      newItem.formatted = {};\n      newItem.formatted.audio = new Int16Array(0);\n      newItem.formatted.text = '';\n      newItem.formatted.transcript = '';\n      // If we have a speech item, can populate audio\n      if (this.queuedSpeechItems[newItem.id]) {\n        newItem.formatted.audio = this.queuedSpeechItems[newItem.id].audio;\n        delete this.queuedSpeechItems[newItem.id]; // free up some memory\n      }\n      // Populate formatted text if it comes out on creation\n      if (newItem.content) {\n        const textContent = newItem.content.filter((c) =>\n          ['text', 'input_text'].includes(c.type),\n        );\n        for (const content of textContent) {\n          newItem.formatted.text += content.text;\n        }\n      }\n      // If we have a transcript item, can pre-populate transcript\n      if (this.queuedTranscriptItems[newItem.id]) {\n        newItem.formatted.transcript = this.queuedTranscriptItems.transcript;\n        delete this.queuedTranscriptItems[newItem.id];\n      }\n      if (newItem.type === 'message') {\n        if (newItem.role === 'user') {\n          newItem.status = 'completed';\n          if (this.queuedInputAudio) {\n            newItem.formatted.audio = this.queuedInputAudio;\n            this.queuedInputAudio = null;\n          }\n        } else {\n          newItem.status = 'in_progress';\n        }\n      } else if (newItem.type === 'function_call') {\n        newItem.formatted.tool = {\n          type: 'function',\n          name: newItem.name,\n          call_id: newItem.call_id,\n          arguments: '',\n        };\n        newItem.status = 'in_progress';\n      } else if (newItem.type === 'function_call_output') {\n        newItem.status = 'completed';\n        newItem.formatted.output = newItem.output;\n      }\n      return { item: newItem, delta: null };\n    },\n    'conversation.item.truncated': (event) => {\n      const { item_id, audio_end_ms } = event;\n      const item = this.itemLookup[item_id];\n      if (!item) {\n        throw new Error(`item.truncated: Item \"${item_id}\" not found`);\n      }\n      const endIndex = Math.floor(\n        (audio_end_ms * this.defaultFrequency) / 1000,\n      );\n      item.formatted.transcript = '';\n      item.formatted.audio = item.formatted.audio.slice(0, endIndex);\n      return { item, delta: null };\n    },\n    'conversation.item.deleted': (event) => {\n      const { item_id } = event;\n      const item = this.itemLookup[item_id];\n      if (!item) {\n        throw new Error(`item.deleted: Item \"${item_id}\" not found`);\n      }\n      delete this.itemLookup[item.id];\n      const index = this.items.indexOf(item);\n      if (index > -1) {\n        this.items.splice(index, 1);\n      }\n      return { item, delta: null };\n    },\n    'conversation.item.input_audio_transcription.completed': (event) => {\n      const { item_id, content_index, transcript } = event;\n      const item = this.itemLookup[item_id];\n      // We use a single space to represent an empty transcript for .formatted values\n      // Otherwise it looks like no transcript provided\n      const formattedTranscript = transcript || ' ';\n      if (!item) {\n        // We can receive transcripts in VAD mode before item.created\n        // This happens specifically when audio is empty\n        this.queuedTranscriptItems[item_id] = {\n          transcript: formattedTranscript,\n        };\n        return { item: null, delta: null };\n      } else {\n        item.content[content_index].transcript = transcript;\n        item.formatted.transcript = formattedTranscript;\n        return { item, delta: { transcript } };\n      }\n    },\n    'input_audio_buffer.speech_started': (event) => {\n      const { item_id, audio_start_ms } = event;\n      this.queuedSpeechItems[item_id] = { audio_start_ms };\n      return { item: null, delta: null };\n    },\n    'input_audio_buffer.speech_stopped': (event, inputAudioBuffer) => {\n      const { item_id, audio_end_ms } = event;\n      const speech = this.queuedSpeechItems[item_id];\n      speech.audio_end_ms = audio_end_ms;\n      if (inputAudioBuffer) {\n        const startIndex = Math.floor(\n          (speech.audio_start_ms * this.defaultFrequency) / 1000,\n        );\n        const endIndex = Math.floor(\n          (speech.audio_end_ms * this.defaultFrequency) / 1000,\n        );\n        speech.audio = inputAudioBuffer.slice(startIndex, endIndex);\n      }\n      return { item: null, delta: null };\n    },\n    'response.created': (event) => {\n      const { response } = event;\n      if (!this.responseLookup[response.id]) {\n        this.responseLookup[response.id] = response;\n        this.responses.push(response);\n      }\n      return { item: null, delta: null };\n    },\n    'response.output_item.added': (event) => {\n      const { response_id, item } = event;\n      const response = this.responseLookup[response_id];\n      if (!response) {\n        throw new Error(\n          `response.output_item.added: Response \"${response_id}\" not found`,\n        );\n      }\n      response.output.push(item.id);\n      return { item: null, delta: null };\n    },\n    'response.output_item.done': (event) => {\n      const { item } = event;\n      if (!item) {\n        throw new Error(`response.output_item.done: Missing \"item\"`);\n      }\n      const foundItem = this.itemLookup[item.id];\n      if (!foundItem) {\n        throw new Error(\n          `response.output_item.done: Item \"${item.id}\" not found`,\n        );\n      }\n      foundItem.status = item.status;\n      return { item: foundItem, delta: null };\n    },\n    'response.content_part.added': (event) => {\n      const { item_id, part } = event;\n      const item = this.itemLookup[item_id];\n      if (!item) {\n        throw new Error(\n          `response.content_part.added: Item \"${item_id}\" not found`,\n        );\n      }\n      item.content.push(part);\n      return { item, delta: null };\n    },\n    'response.audio_transcript.delta': (event) => {\n      const { item_id, content_index, delta } = event;\n      const item = this.itemLookup[item_id];\n      if (!item) {\n        throw new Error(\n          `response.audio_transcript.delta: Item \"${item_id}\" not found`,\n        );\n      }\n      item.content[content_index].transcript += delta;\n      item.formatted.transcript += delta;\n      return { item, delta: { transcript: delta } };\n    },\n    'response.audio.delta': (event) => {\n      const { item_id, content_index, delta } = event;\n      const item = this.itemLookup[item_id];\n      if (!item) {\n        throw new Error(`response.audio.delta: Item \"${item_id}\" not found`);\n      }\n      // This never gets renderered, we care about the file data instead\n      // item.content[content_index].audio += delta;\n      const arrayBuffer = RealtimeUtils.base64ToArrayBuffer(delta);\n      const appendValues = new Int16Array(arrayBuffer);\n      item.formatted.audio = RealtimeUtils.mergeInt16Arrays(\n        item.formatted.audio,\n        appendValues,\n      );\n      return { item, delta: { audio: appendValues } };\n    },\n    'response.text.delta': (event) => {\n      const { item_id, content_index, delta } = event;\n      const item = this.itemLookup[item_id];\n      if (!item) {\n        throw new Error(`response.text.delta: Item \"${item_id}\" not found`);\n      }\n      item.content[content_index].text += delta;\n      item.formatted.text += delta;\n      return { item, delta: { text: delta } };\n    },\n    'response.function_call_arguments.delta': (event) => {\n      const { item_id, delta } = event;\n      const item = this.itemLookup[item_id];\n      if (!item) {\n        throw new Error(\n          `response.function_call_arguments.delta: Item \"${item_id}\" not found`,\n        );\n      }\n      item.arguments += delta;\n      item.formatted.tool.arguments += delta;\n      return { item, delta: { arguments: delta } };\n    },\n  };\n\n  /**\n   * Create a new RealtimeConversation instance\n   * @returns {RealtimeConversation}\n   */\n  constructor() {\n    this.clear();\n  }\n\n  /**\n   * Clears the conversation history and resets to default\n   * @returns {true}\n   */\n  clear() {\n    this.itemLookup = {};\n    this.items = [];\n    this.responseLookup = {};\n    this.responses = [];\n    this.queuedSpeechItems = {};\n    this.queuedTranscriptItems = {};\n    this.queuedInputAudio = null;\n    return true;\n  }\n\n  /**\n   * Queue input audio for manual speech event\n   * @param {Int16Array} inputAudio\n   * @returns {Int16Array}\n   */\n  queueInputAudio(inputAudio) {\n    this.queuedInputAudio = inputAudio;\n    return inputAudio;\n  }\n\n  /**\n   * Process an event from the WebSocket server and compose items\n   * @param {Object} event\n   * @param  {...any} args\n   * @returns {item: import('./client.js').ItemType | null, delta: ItemContentDeltaType | null}\n   */\n  processEvent(event, ...args) {\n    if (!event.event_id) {\n      console.error(event);\n      throw new Error(`Missing \"event_id\" on event`);\n    }\n    if (!event.type) {\n      console.error(event);\n      throw new Error(`Missing \"type\" on event`);\n    }\n    const eventProcessor = this.EventProcessors[event.type];\n    if (!eventProcessor) {\n      throw new Error(\n        `Missing conversation event processor for \"${event.type}\"`,\n      );\n    }\n    return eventProcessor.call(this, event, ...args);\n  }\n\n  /**\n   * Retrieves a item by id\n   * @param {string} id\n   * @returns {import('./client.js').ItemType}\n   */\n  getItem(id) {\n    return this.itemLookup[id] || null;\n  }\n\n  /**\n   * Retrieves all items in the conversation\n   * @returns {import('./client.js').ItemType[]}\n   */\n  getItems() {\n    return this.items.slice();\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}