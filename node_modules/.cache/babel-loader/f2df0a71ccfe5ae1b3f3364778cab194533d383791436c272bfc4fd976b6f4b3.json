{"ast":null,"code":"import { RealtimeUtils } from './utils.js';\n\n/**\n * Contains text and audio information about a item\n * Can also be used as a delta\n * @typedef {Object} ItemContentDeltaType\n * @property {string} [text]\n * @property {Int16Array} [audio]\n * @property {string} [arguments]\n * @property {string} [transcript]\n */\n\n/**\n * RealtimeConversation holds conversation history\n * and performs event validation for RealtimeAPI\n * @class\n */\nexport class RealtimeConversation {\n  /**\n   * Create a new RealtimeConversation instance\n   * @returns {RealtimeConversation}\n   */\n  constructor() {\n    this.defaultFrequency = 24000;\n    // 24,000 Hz\n    this.EventProcessors = {\n      'conversation.item.created': event => {\n        const {\n          item\n        } = event;\n        // deep copy values\n        const newItem = JSON.parse(JSON.stringify(item));\n        if (!this.itemLookup[newItem.id]) {\n          this.itemLookup[newItem.id] = newItem;\n          this.items.push(newItem);\n        }\n        newItem.formatted = {};\n        newItem.formatted.audio = new Int16Array(0);\n        newItem.formatted.text = '';\n        newItem.formatted.transcript = '';\n        // If we have a speech item, can populate audio\n        if (this.queuedSpeechItems[newItem.id]) {\n          newItem.formatted.audio = this.queuedSpeechItems[newItem.id].audio;\n          delete this.queuedSpeechItems[newItem.id]; // free up some memory\n        }\n        // Populate formatted text if it comes out on creation\n        if (newItem.content) {\n          const textContent = newItem.content.filter(c => ['text', 'input_text'].includes(c.type));\n          for (const content of textContent) {\n            newItem.formatted.text += content.text;\n          }\n        }\n        // If we have a transcript item, can pre-populate transcript\n        if (this.queuedTranscriptItems[newItem.id]) {\n          newItem.formatted.transcript = this.queuedTranscriptItems.transcript;\n          delete this.queuedTranscriptItems[newItem.id];\n        }\n        if (newItem.type === 'message') {\n          if (newItem.role === 'user') {\n            newItem.status = 'completed';\n            if (this.queuedInputAudio) {\n              newItem.formatted.audio = this.queuedInputAudio;\n              this.queuedInputAudio = null;\n            }\n          } else {\n            newItem.status = 'in_progress';\n          }\n        } else if (newItem.type === 'function_call') {\n          newItem.formatted.tool = {\n            type: 'function',\n            name: newItem.name,\n            call_id: newItem.call_id,\n            arguments: ''\n          };\n          newItem.status = 'in_progress';\n        } else if (newItem.type === 'function_call_output') {\n          newItem.status = 'completed';\n          newItem.formatted.output = newItem.output;\n        }\n        return {\n          item: newItem,\n          delta: null\n        };\n      },\n      'conversation.item.truncated': event => {\n        const {\n          item_id,\n          audio_end_ms\n        } = event;\n        const item = this.itemLookup[item_id];\n        if (!item) {\n          throw new Error(`item.truncated: Item \"${item_id}\" not found`);\n        }\n        const endIndex = Math.floor(audio_end_ms * this.defaultFrequency / 1000);\n        item.formatted.transcript = '';\n        item.formatted.audio = item.formatted.audio.slice(0, endIndex);\n        return {\n          item,\n          delta: null\n        };\n      },\n      'conversation.item.deleted': event => {\n        const {\n          item_id\n        } = event;\n        const item = this.itemLookup[item_id];\n        if (!item) {\n          throw new Error(`item.deleted: Item \"${item_id}\" not found`);\n        }\n        delete this.itemLookup[item.id];\n        const index = this.items.indexOf(item);\n        if (index > -1) {\n          this.items.splice(index, 1);\n        }\n        return {\n          item,\n          delta: null\n        };\n      },\n      'conversation.item.input_audio_transcription.completed': event => {\n        const {\n          item_id,\n          content_index,\n          transcript\n        } = event;\n        const item = this.itemLookup[item_id];\n        // We use a single space to represent an empty transcript for .formatted values\n        // Otherwise it looks like no transcript provided\n        const formattedTranscript = transcript || ' ';\n        if (!item) {\n          // We can receive transcripts in VAD mode before item.created\n          // This happens specifically when audio is empty\n          this.queuedTranscriptItems[item_id] = {\n            transcript: formattedTranscript\n          };\n          return {\n            item: null,\n            delta: null\n          };\n        } else {\n          item.content[content_index].transcript = transcript;\n          item.formatted.transcript = formattedTranscript;\n          return {\n            item,\n            delta: {\n              transcript\n            }\n          };\n        }\n      },\n      'input_audio_buffer.speech_started': event => {\n        const {\n          item_id,\n          audio_start_ms\n        } = event;\n        this.queuedSpeechItems[item_id] = {\n          audio_start_ms\n        };\n        return {\n          item: null,\n          delta: null\n        };\n      },\n      'input_audio_buffer.speech_stopped': (event, inputAudioBuffer) => {\n        const {\n          item_id,\n          audio_end_ms\n        } = event;\n        const speech = this.queuedSpeechItems[item_id];\n        speech.audio_end_ms = audio_end_ms;\n        if (inputAudioBuffer) {\n          const startIndex = Math.floor(speech.audio_start_ms * this.defaultFrequency / 1000);\n          const endIndex = Math.floor(speech.audio_end_ms * this.defaultFrequency / 1000);\n          speech.audio = inputAudioBuffer.slice(startIndex, endIndex);\n        }\n        return {\n          item: null,\n          delta: null\n        };\n      },\n      'response.created': event => {\n        const {\n          response\n        } = event;\n        if (!this.responseLookup[response.id]) {\n          this.responseLookup[response.id] = response;\n          this.responses.push(response);\n        }\n        return {\n          item: null,\n          delta: null\n        };\n      },\n      'response.output_item.added': event => {\n        const {\n          response_id,\n          item\n        } = event;\n        const response = this.responseLookup[response_id];\n        if (!response) {\n          throw new Error(`response.output_item.added: Response \"${response_id}\" not found`);\n        }\n        response.output.push(item.id);\n        return {\n          item: null,\n          delta: null\n        };\n      },\n      'response.output_item.done': event => {\n        const {\n          item\n        } = event;\n        if (!item) {\n          throw new Error(`response.output_item.done: Missing \"item\"`);\n        }\n        const foundItem = this.itemLookup[item.id];\n        if (!foundItem) {\n          throw new Error(`response.output_item.done: Item \"${item.id}\" not found`);\n        }\n        foundItem.status = item.status;\n        return {\n          item: foundItem,\n          delta: null\n        };\n      },\n      'response.content_part.added': event => {\n        const {\n          item_id,\n          part\n        } = event;\n        const item = this.itemLookup[item_id];\n        if (!item) {\n          throw new Error(`response.content_part.added: Item \"${item_id}\" not found`);\n        }\n        item.content.push(part);\n        return {\n          item,\n          delta: null\n        };\n      },\n      'response.audio_transcript.delta': event => {\n        const {\n          item_id,\n          content_index,\n          delta\n        } = event;\n        const item = this.itemLookup[item_id];\n        if (!item) {\n          throw new Error(`response.audio_transcript.delta: Item \"${item_id}\" not found`);\n        }\n        item.content[content_index].transcript += delta;\n        item.formatted.transcript += delta;\n        return {\n          item,\n          delta: {\n            transcript: delta\n          }\n        };\n      },\n      'response.audio.delta': event => {\n        const {\n          item_id,\n          content_index,\n          delta\n        } = event;\n        const item = this.itemLookup[item_id];\n        if (!item) {\n          throw new Error(`response.audio.delta: Item \"${item_id}\" not found`);\n        }\n        // This never gets renderered, we care about the file data instead\n        // item.content[content_index].audio += delta;\n        const arrayBuffer = RealtimeUtils.base64ToArrayBuffer(delta);\n        const appendValues = new Int16Array(arrayBuffer);\n        item.formatted.audio = RealtimeUtils.mergeInt16Arrays(item.formatted.audio, appendValues);\n        return {\n          item,\n          delta: {\n            audio: appendValues\n          }\n        };\n      },\n      'response.text.delta': event => {\n        const {\n          item_id,\n          content_index,\n          delta\n        } = event;\n        const item = this.itemLookup[item_id];\n        if (!item) {\n          throw new Error(`response.text.delta: Item \"${item_id}\" not found`);\n        }\n        item.content[content_index].text += delta;\n        item.formatted.text += delta;\n        return {\n          item,\n          delta: {\n            text: delta\n          }\n        };\n      },\n      'response.function_call_arguments.delta': event => {\n        const {\n          item_id,\n          delta\n        } = event;\n        const item = this.itemLookup[item_id];\n        if (!item) {\n          throw new Error(`response.function_call_arguments.delta: Item \"${item_id}\" not found`);\n        }\n        item.arguments += delta;\n        item.formatted.tool.arguments += delta;\n        return {\n          item,\n          delta: {\n            arguments: delta\n          }\n        };\n      }\n    };\n    this.clear();\n  }\n\n  /**\n   * Clears the conversation history and resets to default\n   * @returns {true}\n   */\n  clear() {\n    this.itemLookup = {};\n    this.items = [];\n    this.responseLookup = {};\n    this.responses = [];\n    this.queuedSpeechItems = {};\n    this.queuedTranscriptItems = {};\n    this.queuedInputAudio = null;\n    return true;\n  }\n\n  /**\n   * Queue input audio for manual speech event\n   * @param {Int16Array} inputAudio\n   * @returns {Int16Array}\n   */\n  queueInputAudio(inputAudio) {\n    this.queuedInputAudio = inputAudio;\n    return inputAudio;\n  }\n\n  /**\n   * Process an event from the WebSocket server and compose items\n   * @param {Object} event\n   * @param  {...any} args\n   * @returns {item: import('./client.js').ItemType | null, delta: ItemContentDeltaType | null}\n   */\n  processEvent(event, ...args) {\n    if (!event.event_id) {\n      console.error(event);\n      throw new Error(`Missing \"event_id\" on event`);\n    }\n    if (!event.type) {\n      console.error(event);\n      throw new Error(`Missing \"type\" on event`);\n    }\n    const eventProcessor = this.EventProcessors[event.type];\n    if (!eventProcessor) {\n      throw new Error(`Missing conversation event processor for \"${event.type}\"`);\n    }\n    return eventProcessor.call(this, event, ...args);\n  }\n\n  /**\n   * Retrieves a item by id\n   * @param {string} id\n   * @returns {import('./client.js').ItemType}\n   */\n  getItem(id) {\n    return this.itemLookup[id] || null;\n  }\n\n  /**\n   * Retrieves all items in the conversation\n   * @returns {import('./client.js').ItemType[]}\n   */\n  getItems() {\n    return this.items.slice();\n  }\n}","map":{"version":3,"names":["RealtimeUtils","RealtimeConversation","constructor","defaultFrequency","EventProcessors","event","item","newItem","JSON","parse","stringify","itemLookup","id","items","push","formatted","audio","Int16Array","text","transcript","queuedSpeechItems","content","textContent","filter","c","includes","type","queuedTranscriptItems","role","status","queuedInputAudio","tool","name","call_id","arguments","output","delta","item_id","audio_end_ms","Error","endIndex","Math","floor","slice","index","indexOf","splice","content_index","formattedTranscript","audio_start_ms","input_audio_buffer.speech_stopped","inputAudioBuffer","speech","startIndex","response","responseLookup","responses","response_id","foundItem","part","arrayBuffer","base64ToArrayBuffer","appendValues","mergeInt16Arrays","clear","queueInputAudio","inputAudio","processEvent","args","event_id","console","error","eventProcessor","call","getItem","getItems"],"sources":["/Users/johnpaulreju/git_dashboard/simli/simli-openai-realtime/src/lib/realtime-api-beta/lib/conversation.js"],"sourcesContent":["import { RealtimeUtils } from './utils.js';\n\n/**\n * Contains text and audio information about a item\n * Can also be used as a delta\n * @typedef {Object} ItemContentDeltaType\n * @property {string} [text]\n * @property {Int16Array} [audio]\n * @property {string} [arguments]\n * @property {string} [transcript]\n */\n\n/**\n * RealtimeConversation holds conversation history\n * and performs event validation for RealtimeAPI\n * @class\n */\nexport class RealtimeConversation {\n  defaultFrequency = 24_000; // 24,000 Hz\n\n  EventProcessors = {\n    'conversation.item.created': (event) => {\n      const { item } = event;\n      // deep copy values\n      const newItem = JSON.parse(JSON.stringify(item));\n      if (!this.itemLookup[newItem.id]) {\n        this.itemLookup[newItem.id] = newItem;\n        this.items.push(newItem);\n      }\n      newItem.formatted = {};\n      newItem.formatted.audio = new Int16Array(0);\n      newItem.formatted.text = '';\n      newItem.formatted.transcript = '';\n      // If we have a speech item, can populate audio\n      if (this.queuedSpeechItems[newItem.id]) {\n        newItem.formatted.audio = this.queuedSpeechItems[newItem.id].audio;\n        delete this.queuedSpeechItems[newItem.id]; // free up some memory\n      }\n      // Populate formatted text if it comes out on creation\n      if (newItem.content) {\n        const textContent = newItem.content.filter((c) =>\n          ['text', 'input_text'].includes(c.type),\n        );\n        for (const content of textContent) {\n          newItem.formatted.text += content.text;\n        }\n      }\n      // If we have a transcript item, can pre-populate transcript\n      if (this.queuedTranscriptItems[newItem.id]) {\n        newItem.formatted.transcript = this.queuedTranscriptItems.transcript;\n        delete this.queuedTranscriptItems[newItem.id];\n      }\n      if (newItem.type === 'message') {\n        if (newItem.role === 'user') {\n          newItem.status = 'completed';\n          if (this.queuedInputAudio) {\n            newItem.formatted.audio = this.queuedInputAudio;\n            this.queuedInputAudio = null;\n          }\n        } else {\n          newItem.status = 'in_progress';\n        }\n      } else if (newItem.type === 'function_call') {\n        newItem.formatted.tool = {\n          type: 'function',\n          name: newItem.name,\n          call_id: newItem.call_id,\n          arguments: '',\n        };\n        newItem.status = 'in_progress';\n      } else if (newItem.type === 'function_call_output') {\n        newItem.status = 'completed';\n        newItem.formatted.output = newItem.output;\n      }\n      return { item: newItem, delta: null };\n    },\n    'conversation.item.truncated': (event) => {\n      const { item_id, audio_end_ms } = event;\n      const item = this.itemLookup[item_id];\n      if (!item) {\n        throw new Error(`item.truncated: Item \"${item_id}\" not found`);\n      }\n      const endIndex = Math.floor(\n        (audio_end_ms * this.defaultFrequency) / 1000,\n      );\n      item.formatted.transcript = '';\n      item.formatted.audio = item.formatted.audio.slice(0, endIndex);\n      return { item, delta: null };\n    },\n    'conversation.item.deleted': (event) => {\n      const { item_id } = event;\n      const item = this.itemLookup[item_id];\n      if (!item) {\n        throw new Error(`item.deleted: Item \"${item_id}\" not found`);\n      }\n      delete this.itemLookup[item.id];\n      const index = this.items.indexOf(item);\n      if (index > -1) {\n        this.items.splice(index, 1);\n      }\n      return { item, delta: null };\n    },\n    'conversation.item.input_audio_transcription.completed': (event) => {\n      const { item_id, content_index, transcript } = event;\n      const item = this.itemLookup[item_id];\n      // We use a single space to represent an empty transcript for .formatted values\n      // Otherwise it looks like no transcript provided\n      const formattedTranscript = transcript || ' ';\n      if (!item) {\n        // We can receive transcripts in VAD mode before item.created\n        // This happens specifically when audio is empty\n        this.queuedTranscriptItems[item_id] = {\n          transcript: formattedTranscript,\n        };\n        return { item: null, delta: null };\n      } else {\n        item.content[content_index].transcript = transcript;\n        item.formatted.transcript = formattedTranscript;\n        return { item, delta: { transcript } };\n      }\n    },\n    'input_audio_buffer.speech_started': (event) => {\n      const { item_id, audio_start_ms } = event;\n      this.queuedSpeechItems[item_id] = { audio_start_ms };\n      return { item: null, delta: null };\n    },\n    'input_audio_buffer.speech_stopped': (event, inputAudioBuffer) => {\n      const { item_id, audio_end_ms } = event;\n      const speech = this.queuedSpeechItems[item_id];\n      speech.audio_end_ms = audio_end_ms;\n      if (inputAudioBuffer) {\n        const startIndex = Math.floor(\n          (speech.audio_start_ms * this.defaultFrequency) / 1000,\n        );\n        const endIndex = Math.floor(\n          (speech.audio_end_ms * this.defaultFrequency) / 1000,\n        );\n        speech.audio = inputAudioBuffer.slice(startIndex, endIndex);\n      }\n      return { item: null, delta: null };\n    },\n    'response.created': (event) => {\n      const { response } = event;\n      if (!this.responseLookup[response.id]) {\n        this.responseLookup[response.id] = response;\n        this.responses.push(response);\n      }\n      return { item: null, delta: null };\n    },\n    'response.output_item.added': (event) => {\n      const { response_id, item } = event;\n      const response = this.responseLookup[response_id];\n      if (!response) {\n        throw new Error(\n          `response.output_item.added: Response \"${response_id}\" not found`,\n        );\n      }\n      response.output.push(item.id);\n      return { item: null, delta: null };\n    },\n    'response.output_item.done': (event) => {\n      const { item } = event;\n      if (!item) {\n        throw new Error(`response.output_item.done: Missing \"item\"`);\n      }\n      const foundItem = this.itemLookup[item.id];\n      if (!foundItem) {\n        throw new Error(\n          `response.output_item.done: Item \"${item.id}\" not found`,\n        );\n      }\n      foundItem.status = item.status;\n      return { item: foundItem, delta: null };\n    },\n    'response.content_part.added': (event) => {\n      const { item_id, part } = event;\n      const item = this.itemLookup[item_id];\n      if (!item) {\n        throw new Error(\n          `response.content_part.added: Item \"${item_id}\" not found`,\n        );\n      }\n      item.content.push(part);\n      return { item, delta: null };\n    },\n    'response.audio_transcript.delta': (event) => {\n      const { item_id, content_index, delta } = event;\n      const item = this.itemLookup[item_id];\n      if (!item) {\n        throw new Error(\n          `response.audio_transcript.delta: Item \"${item_id}\" not found`,\n        );\n      }\n      item.content[content_index].transcript += delta;\n      item.formatted.transcript += delta;\n      return { item, delta: { transcript: delta } };\n    },\n    'response.audio.delta': (event) => {\n      const { item_id, content_index, delta } = event;\n      const item = this.itemLookup[item_id];\n      if (!item) {\n        throw new Error(`response.audio.delta: Item \"${item_id}\" not found`);\n      }\n      // This never gets renderered, we care about the file data instead\n      // item.content[content_index].audio += delta;\n      const arrayBuffer = RealtimeUtils.base64ToArrayBuffer(delta);\n      const appendValues = new Int16Array(arrayBuffer);\n      item.formatted.audio = RealtimeUtils.mergeInt16Arrays(\n        item.formatted.audio,\n        appendValues,\n      );\n      return { item, delta: { audio: appendValues } };\n    },\n    'response.text.delta': (event) => {\n      const { item_id, content_index, delta } = event;\n      const item = this.itemLookup[item_id];\n      if (!item) {\n        throw new Error(`response.text.delta: Item \"${item_id}\" not found`);\n      }\n      item.content[content_index].text += delta;\n      item.formatted.text += delta;\n      return { item, delta: { text: delta } };\n    },\n    'response.function_call_arguments.delta': (event) => {\n      const { item_id, delta } = event;\n      const item = this.itemLookup[item_id];\n      if (!item) {\n        throw new Error(\n          `response.function_call_arguments.delta: Item \"${item_id}\" not found`,\n        );\n      }\n      item.arguments += delta;\n      item.formatted.tool.arguments += delta;\n      return { item, delta: { arguments: delta } };\n    },\n  };\n\n  /**\n   * Create a new RealtimeConversation instance\n   * @returns {RealtimeConversation}\n   */\n  constructor() {\n    this.clear();\n  }\n\n  /**\n   * Clears the conversation history and resets to default\n   * @returns {true}\n   */\n  clear() {\n    this.itemLookup = {};\n    this.items = [];\n    this.responseLookup = {};\n    this.responses = [];\n    this.queuedSpeechItems = {};\n    this.queuedTranscriptItems = {};\n    this.queuedInputAudio = null;\n    return true;\n  }\n\n  /**\n   * Queue input audio for manual speech event\n   * @param {Int16Array} inputAudio\n   * @returns {Int16Array}\n   */\n  queueInputAudio(inputAudio) {\n    this.queuedInputAudio = inputAudio;\n    return inputAudio;\n  }\n\n  /**\n   * Process an event from the WebSocket server and compose items\n   * @param {Object} event\n   * @param  {...any} args\n   * @returns {item: import('./client.js').ItemType | null, delta: ItemContentDeltaType | null}\n   */\n  processEvent(event, ...args) {\n    if (!event.event_id) {\n      console.error(event);\n      throw new Error(`Missing \"event_id\" on event`);\n    }\n    if (!event.type) {\n      console.error(event);\n      throw new Error(`Missing \"type\" on event`);\n    }\n    const eventProcessor = this.EventProcessors[event.type];\n    if (!eventProcessor) {\n      throw new Error(\n        `Missing conversation event processor for \"${event.type}\"`,\n      );\n    }\n    return eventProcessor.call(this, event, ...args);\n  }\n\n  /**\n   * Retrieves a item by id\n   * @param {string} id\n   * @returns {import('./client.js').ItemType}\n   */\n  getItem(id) {\n    return this.itemLookup[id] || null;\n  }\n\n  /**\n   * Retrieves all items in the conversation\n   * @returns {import('./client.js').ItemType[]}\n   */\n  getItems() {\n    return this.items.slice();\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}