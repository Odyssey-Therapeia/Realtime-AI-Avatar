{"ast":null,"code":"/**\n * Raw wav audio file contents\n * @typedef {Object} WavPackerAudioType\n * @property {Blob} blob\n * @property {string} url\n * @property {number} channelCount\n * @property {number} sampleRate\n * @property {number} duration\n *//**\n * Utility class for assembling PCM16 \"audio/wav\" data\n * @class\n */export class WavPacker{/**\n   * Converts Float32Array of amplitude data to ArrayBuffer in Int16Array format\n   * @param {Float32Array} float32Array\n   * @returns {ArrayBuffer}\n   */static floatTo16BitPCM(float32Array){const buffer=new ArrayBuffer(float32Array.length*2);const view=new DataView(buffer);let offset=0;for(let i=0;i<float32Array.length;i++,offset+=2){let s=Math.max(-1,Math.min(1,float32Array[i]));view.setInt16(offset,s<0?s*0x8000:s*0x7fff,true);}return buffer;}/**\n   * Concatenates two ArrayBuffers\n   * @param {ArrayBuffer} leftBuffer\n   * @param {ArrayBuffer} rightBuffer\n   * @returns {ArrayBuffer}\n   */static mergeBuffers(leftBuffer,rightBuffer){const tmpArray=new Uint8Array(leftBuffer.byteLength+rightBuffer.byteLength);tmpArray.set(new Uint8Array(leftBuffer),0);tmpArray.set(new Uint8Array(rightBuffer),leftBuffer.byteLength);return tmpArray.buffer;}/**\n   * Packs data into an Int16 format\n   * @private\n   * @param {number} size 0 = 1x Int16, 1 = 2x Int16\n   * @param {number} arg value to pack\n   * @returns\n   */_packData(size,arg){return[new Uint8Array([arg,arg>>8]),new Uint8Array([arg,arg>>8,arg>>16,arg>>24])][size];}/**\n   * Packs audio into \"audio/wav\" Blob\n   * @param {number} sampleRate\n   * @param {{bitsPerSample: number, channels: Array<Float32Array>, data: Int16Array}} audio\n   * @returns {WavPackerAudioType}\n   */pack(sampleRate,audio){if(!(audio!==null&&audio!==void 0&&audio.bitsPerSample)){throw new Error(`Missing \"bitsPerSample\"`);}else if(!(audio!==null&&audio!==void 0&&audio.channels)){throw new Error(`Missing \"channels\"`);}else if(!(audio!==null&&audio!==void 0&&audio.data)){throw new Error(`Missing \"data\"`);}const{bitsPerSample,channels,data}=audio;const output=[// Header\n'RIFF',this._packData(1,4+(8+24)/* chunk 1 length */+(8+8)/* chunk 2 length */),// Length\n'WAVE',// chunk 1\n'fmt ',// Sub-chunk identifier\nthis._packData(1,16),// Chunk length\nthis._packData(0,1),// Audio format (1 is linear quantization)\nthis._packData(0,channels.length),this._packData(1,sampleRate),this._packData(1,sampleRate*channels.length*bitsPerSample/8),// Byte rate\nthis._packData(0,channels.length*bitsPerSample/8),this._packData(0,bitsPerSample),// chunk 2\n'data',// Sub-chunk identifier\nthis._packData(1,channels[0].length*channels.length*bitsPerSample/8),// Chunk length\ndata];const blob=new Blob(output,{type:'audio/mpeg'});const url=URL.createObjectURL(blob);return{blob,url,channelCount:channels.length,sampleRate,duration:data.byteLength/(channels.length*sampleRate*2)};}}globalThis.WavPacker=WavPacker;","map":{"version":3,"names":["WavPacker","floatTo16BitPCM","float32Array","buffer","ArrayBuffer","length","view","DataView","offset","i","s","Math","max","min","setInt16","mergeBuffers","leftBuffer","rightBuffer","tmpArray","Uint8Array","byteLength","set","_packData","size","arg","pack","sampleRate","audio","bitsPerSample","Error","channels","data","output","blob","Blob","type","url","URL","createObjectURL","channelCount","duration","globalThis"],"sources":["/Users/johnpaulreju/git_dashboard/simli/simli-openai-realtime/src/lib/wavtools/lib/wav_packer.js"],"sourcesContent":["/**\n * Raw wav audio file contents\n * @typedef {Object} WavPackerAudioType\n * @property {Blob} blob\n * @property {string} url\n * @property {number} channelCount\n * @property {number} sampleRate\n * @property {number} duration\n */\n\n/**\n * Utility class for assembling PCM16 \"audio/wav\" data\n * @class\n */\nexport class WavPacker {\n  /**\n   * Converts Float32Array of amplitude data to ArrayBuffer in Int16Array format\n   * @param {Float32Array} float32Array\n   * @returns {ArrayBuffer}\n   */\n  static floatTo16BitPCM(float32Array) {\n    const buffer = new ArrayBuffer(float32Array.length * 2);\n    const view = new DataView(buffer);\n    let offset = 0;\n    for (let i = 0; i < float32Array.length; i++, offset += 2) {\n      let s = Math.max(-1, Math.min(1, float32Array[i]));\n      view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7fff, true);\n    }\n    return buffer;\n  }\n\n  /**\n   * Concatenates two ArrayBuffers\n   * @param {ArrayBuffer} leftBuffer\n   * @param {ArrayBuffer} rightBuffer\n   * @returns {ArrayBuffer}\n   */\n  static mergeBuffers(leftBuffer, rightBuffer) {\n    const tmpArray = new Uint8Array(\n      leftBuffer.byteLength + rightBuffer.byteLength\n    );\n    tmpArray.set(new Uint8Array(leftBuffer), 0);\n    tmpArray.set(new Uint8Array(rightBuffer), leftBuffer.byteLength);\n    return tmpArray.buffer;\n  }\n\n  /**\n   * Packs data into an Int16 format\n   * @private\n   * @param {number} size 0 = 1x Int16, 1 = 2x Int16\n   * @param {number} arg value to pack\n   * @returns\n   */\n  _packData(size, arg) {\n    return [\n      new Uint8Array([arg, arg >> 8]),\n      new Uint8Array([arg, arg >> 8, arg >> 16, arg >> 24]),\n    ][size];\n  }\n\n  /**\n   * Packs audio into \"audio/wav\" Blob\n   * @param {number} sampleRate\n   * @param {{bitsPerSample: number, channels: Array<Float32Array>, data: Int16Array}} audio\n   * @returns {WavPackerAudioType}\n   */\n  pack(sampleRate, audio) {\n    if (!audio?.bitsPerSample) {\n      throw new Error(`Missing \"bitsPerSample\"`);\n    } else if (!audio?.channels) {\n      throw new Error(`Missing \"channels\"`);\n    } else if (!audio?.data) {\n      throw new Error(`Missing \"data\"`);\n    }\n    const { bitsPerSample, channels, data } = audio;\n    const output = [\n      // Header\n      'RIFF',\n      this._packData(\n        1,\n        4 + (8 + 24) /* chunk 1 length */ + (8 + 8) /* chunk 2 length */\n      ), // Length\n      'WAVE',\n      // chunk 1\n      'fmt ', // Sub-chunk identifier\n      this._packData(1, 16), // Chunk length\n      this._packData(0, 1), // Audio format (1 is linear quantization)\n      this._packData(0, channels.length),\n      this._packData(1, sampleRate),\n      this._packData(1, (sampleRate * channels.length * bitsPerSample) / 8), // Byte rate\n      this._packData(0, (channels.length * bitsPerSample) / 8),\n      this._packData(0, bitsPerSample),\n      // chunk 2\n      'data', // Sub-chunk identifier\n      this._packData(\n        1,\n        (channels[0].length * channels.length * bitsPerSample) / 8\n      ), // Chunk length\n      data,\n    ];\n    const blob = new Blob(output, { type: 'audio/mpeg' });\n    const url = URL.createObjectURL(blob);\n    return {\n      blob,\n      url,\n      channelCount: channels.length,\n      sampleRate,\n      duration: data.byteLength / (channels.length * sampleRate * 2),\n    };\n  }\n}\n\nglobalThis.WavPacker = WavPacker;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAEA;AACA;AACA;AACA,GACA,MAAO,MAAM,CAAAA,SAAU,CACrB;AACF;AACA;AACA;AACA,KACE,MAAO,CAAAC,eAAeA,CAACC,YAAY,CAAE,CACnC,KAAM,CAAAC,MAAM,CAAG,GAAI,CAAAC,WAAW,CAACF,YAAY,CAACG,MAAM,CAAG,CAAC,CAAC,CACvD,KAAM,CAAAC,IAAI,CAAG,GAAI,CAAAC,QAAQ,CAACJ,MAAM,CAAC,CACjC,GAAI,CAAAK,MAAM,CAAG,CAAC,CACd,IAAK,GAAI,CAAAC,CAAC,CAAG,CAAC,CAAEA,CAAC,CAAGP,YAAY,CAACG,MAAM,CAAEI,CAAC,EAAE,CAAED,MAAM,EAAI,CAAC,CAAE,CACzD,GAAI,CAAAE,CAAC,CAAGC,IAAI,CAACC,GAAG,CAAC,CAAC,CAAC,CAAED,IAAI,CAACE,GAAG,CAAC,CAAC,CAAEX,YAAY,CAACO,CAAC,CAAC,CAAC,CAAC,CAClDH,IAAI,CAACQ,QAAQ,CAACN,MAAM,CAAEE,CAAC,CAAG,CAAC,CAAGA,CAAC,CAAG,MAAM,CAAGA,CAAC,CAAG,MAAM,CAAE,IAAI,CAAC,CAC9D,CACA,MAAO,CAAAP,MAAM,CACf,CAEA;AACF;AACA;AACA;AACA;AACA,KACE,MAAO,CAAAY,YAAYA,CAACC,UAAU,CAAEC,WAAW,CAAE,CAC3C,KAAM,CAAAC,QAAQ,CAAG,GAAI,CAAAC,UAAU,CAC7BH,UAAU,CAACI,UAAU,CAAGH,WAAW,CAACG,UACtC,CAAC,CACDF,QAAQ,CAACG,GAAG,CAAC,GAAI,CAAAF,UAAU,CAACH,UAAU,CAAC,CAAE,CAAC,CAAC,CAC3CE,QAAQ,CAACG,GAAG,CAAC,GAAI,CAAAF,UAAU,CAACF,WAAW,CAAC,CAAED,UAAU,CAACI,UAAU,CAAC,CAChE,MAAO,CAAAF,QAAQ,CAACf,MAAM,CACxB,CAEA;AACF;AACA;AACA;AACA;AACA;AACA,KACEmB,SAASA,CAACC,IAAI,CAAEC,GAAG,CAAE,CACnB,MAAO,CACL,GAAI,CAAAL,UAAU,CAAC,CAACK,GAAG,CAAEA,GAAG,EAAI,CAAC,CAAC,CAAC,CAC/B,GAAI,CAAAL,UAAU,CAAC,CAACK,GAAG,CAAEA,GAAG,EAAI,CAAC,CAAEA,GAAG,EAAI,EAAE,CAAEA,GAAG,EAAI,EAAE,CAAC,CAAC,CACtD,CAACD,IAAI,CAAC,CACT,CAEA;AACF;AACA;AACA;AACA;AACA,KACEE,IAAIA,CAACC,UAAU,CAAEC,KAAK,CAAE,CACtB,GAAI,EAACA,KAAK,SAALA,KAAK,WAALA,KAAK,CAAEC,aAAa,EAAE,CACzB,KAAM,IAAI,CAAAC,KAAK,CAAC,yBAAyB,CAAC,CAC5C,CAAC,IAAM,IAAI,EAACF,KAAK,SAALA,KAAK,WAALA,KAAK,CAAEG,QAAQ,EAAE,CAC3B,KAAM,IAAI,CAAAD,KAAK,CAAC,oBAAoB,CAAC,CACvC,CAAC,IAAM,IAAI,EAACF,KAAK,SAALA,KAAK,WAALA,KAAK,CAAEI,IAAI,EAAE,CACvB,KAAM,IAAI,CAAAF,KAAK,CAAC,gBAAgB,CAAC,CACnC,CACA,KAAM,CAAED,aAAa,CAAEE,QAAQ,CAAEC,IAAK,CAAC,CAAGJ,KAAK,CAC/C,KAAM,CAAAK,MAAM,CAAG,CACb;AACA,MAAM,CACN,IAAI,CAACV,SAAS,CACZ,CAAC,CACD,CAAC,EAAI,CAAC,CAAG,EAAE,CAAE,sBAAwB,CAAC,CAAG,CAAC,CAAE,oBAC9C,CAAC,CAAE;AACH,MAAM,CACN;AACA,MAAM,CAAE;AACR,IAAI,CAACA,SAAS,CAAC,CAAC,CAAE,EAAE,CAAC,CAAE;AACvB,IAAI,CAACA,SAAS,CAAC,CAAC,CAAE,CAAC,CAAC,CAAE;AACtB,IAAI,CAACA,SAAS,CAAC,CAAC,CAAEQ,QAAQ,CAACzB,MAAM,CAAC,CAClC,IAAI,CAACiB,SAAS,CAAC,CAAC,CAAEI,UAAU,CAAC,CAC7B,IAAI,CAACJ,SAAS,CAAC,CAAC,CAAGI,UAAU,CAAGI,QAAQ,CAACzB,MAAM,CAAGuB,aAAa,CAAI,CAAC,CAAC,CAAE;AACvE,IAAI,CAACN,SAAS,CAAC,CAAC,CAAGQ,QAAQ,CAACzB,MAAM,CAAGuB,aAAa,CAAI,CAAC,CAAC,CACxD,IAAI,CAACN,SAAS,CAAC,CAAC,CAAEM,aAAa,CAAC,CAChC;AACA,MAAM,CAAE;AACR,IAAI,CAACN,SAAS,CACZ,CAAC,CACAQ,QAAQ,CAAC,CAAC,CAAC,CAACzB,MAAM,CAAGyB,QAAQ,CAACzB,MAAM,CAAGuB,aAAa,CAAI,CAC3D,CAAC,CAAE;AACHG,IAAI,CACL,CACD,KAAM,CAAAE,IAAI,CAAG,GAAI,CAAAC,IAAI,CAACF,MAAM,CAAE,CAAEG,IAAI,CAAE,YAAa,CAAC,CAAC,CACrD,KAAM,CAAAC,GAAG,CAAGC,GAAG,CAACC,eAAe,CAACL,IAAI,CAAC,CACrC,MAAO,CACLA,IAAI,CACJG,GAAG,CACHG,YAAY,CAAET,QAAQ,CAACzB,MAAM,CAC7BqB,UAAU,CACVc,QAAQ,CAAET,IAAI,CAACX,UAAU,EAAIU,QAAQ,CAACzB,MAAM,CAAGqB,UAAU,CAAG,CAAC,CAC/D,CAAC,CACH,CACF,CAEAe,UAAU,CAACzC,SAAS,CAAGA,SAAS","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}