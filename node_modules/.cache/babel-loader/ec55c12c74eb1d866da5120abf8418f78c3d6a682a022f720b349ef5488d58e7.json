{"ast":null,"code":"import{StreamProcessorSrc}from'./worklets/stream_processor.js';import{AudioAnalysis}from'./analysis/audio_analysis.js';/**\n * Plays audio streams received in raw PCM16 chunks from the browser\n * @class\n */export class WavStreamPlayer{/**\n   * Creates a new WavStreamPlayer instance\n   * @param {{sampleRate?: number}} options\n   * @returns {WavStreamPlayer}\n   */constructor(){let{sampleRate=44100}=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};this.scriptSrc=StreamProcessorSrc;this.sampleRate=sampleRate;this.context=null;this.stream=null;this.analyser=null;this.trackSampleOffsets={};this.interruptedTrackIds={};}/**\n   * Connects the audio context and enables output to speakers\n   * @returns {Promise<true>}\n   */async connect(){this.context=new AudioContext({sampleRate:this.sampleRate});if(this.context.state==='suspended'){await this.context.resume();}try{await this.context.audioWorklet.addModule(this.scriptSrc);}catch(e){console.error(e);throw new Error(`Could not add audioWorklet module: ${this.scriptSrc}`);}const analyser=this.context.createAnalyser();analyser.fftSize=8192;analyser.smoothingTimeConstant=0.1;this.analyser=analyser;return true;}/**\n   * Gets the current frequency domain data from the playing track\n   * @param {\"frequency\"|\"music\"|\"voice\"} [analysisType]\n   * @param {number} [minDecibels] default -100\n   * @param {number} [maxDecibels] default -30\n   * @returns {import('./analysis/audio_analysis.js').AudioAnalysisOutputType}\n   */getFrequencies(){let analysisType=arguments.length>0&&arguments[0]!==undefined?arguments[0]:'frequency';let minDecibels=arguments.length>1&&arguments[1]!==undefined?arguments[1]:-100;let maxDecibels=arguments.length>2&&arguments[2]!==undefined?arguments[2]:-30;if(!this.analyser){throw new Error('Not connected, please call .connect() first');}return AudioAnalysis.getFrequencies(this.analyser,this.sampleRate,null,analysisType,minDecibels,maxDecibels);}/**\n   * Starts audio streaming\n   * @private\n   * @returns {Promise<true>}\n   */_start(){const streamNode=new AudioWorkletNode(this.context,'stream_processor');streamNode.connect(this.context.destination);streamNode.port.onmessage=e=>{const{event}=e.data;if(event==='stop'){streamNode.disconnect();this.stream=null;}else if(event==='offset'){const{requestId,trackId,offset}=e.data;const currentTime=offset/this.sampleRate;this.trackSampleOffsets[requestId]={trackId,offset,currentTime};}};this.analyser.disconnect();streamNode.connect(this.analyser);this.stream=streamNode;return true;}/**\n   * Adds 16BitPCM data to the currently playing audio stream\n   * You can add chunks beyond the current play point and they will be queued for play\n   * @param {ArrayBuffer|Int16Array} arrayBuffer\n   * @param {string} [trackId]\n   * @returns {Int16Array}\n   */add16BitPCM(arrayBuffer){let trackId=arguments.length>1&&arguments[1]!==undefined?arguments[1]:'default';if(typeof trackId!=='string'){throw new Error(`trackId must be a string`);}else if(this.interruptedTrackIds[trackId]){return;}if(!this.stream){this._start();}let buffer;if(arrayBuffer instanceof Int16Array){buffer=arrayBuffer;}else if(arrayBuffer instanceof ArrayBuffer){buffer=new Int16Array(arrayBuffer);}else{throw new Error(`argument must be Int16Array or ArrayBuffer`);}this.stream.port.postMessage({event:'write',buffer,trackId});return buffer;}/**\n   * Gets the offset (sample count) of the currently playing stream\n   * @param {boolean} [interrupt]\n   * @returns {{trackId: string|null, offset: number, currentTime: number}}\n   */async getTrackSampleOffset(){let interrupt=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;if(!this.stream){return null;}const requestId=crypto.randomUUID();this.stream.port.postMessage({event:interrupt?'interrupt':'offset',requestId});let trackSampleOffset;while(!trackSampleOffset){trackSampleOffset=this.trackSampleOffsets[requestId];await new Promise(r=>setTimeout(()=>r(),1));}const{trackId}=trackSampleOffset;if(interrupt&&trackId){this.interruptedTrackIds[trackId]=true;}return trackSampleOffset;}/**\n   * Strips the current stream and returns the sample offset of the audio\n   * @param {boolean} [interrupt]\n   * @returns {{trackId: string|null, offset: number, currentTime: number}}\n   */async interrupt(){return this.getTrackSampleOffset(true);}}globalThis.WavStreamPlayer=WavStreamPlayer;","map":{"version":3,"names":["StreamProcessorSrc","AudioAnalysis","WavStreamPlayer","constructor","sampleRate","arguments","length","undefined","scriptSrc","context","stream","analyser","trackSampleOffsets","interruptedTrackIds","connect","AudioContext","state","resume","audioWorklet","addModule","e","console","error","Error","createAnalyser","fftSize","smoothingTimeConstant","getFrequencies","analysisType","minDecibels","maxDecibels","_start","streamNode","AudioWorkletNode","destination","port","onmessage","event","data","disconnect","requestId","trackId","offset","currentTime","add16BitPCM","arrayBuffer","buffer","Int16Array","ArrayBuffer","postMessage","getTrackSampleOffset","interrupt","crypto","randomUUID","trackSampleOffset","Promise","r","setTimeout","globalThis"],"sources":["/Users/johnpaulreju/git_dashboard/simli/simli-openai-realtime/src/lib/wavtools/lib/wav_stream_player.js"],"sourcesContent":["import { StreamProcessorSrc } from './worklets/stream_processor.js';\nimport { AudioAnalysis } from './analysis/audio_analysis.js';\n\n/**\n * Plays audio streams received in raw PCM16 chunks from the browser\n * @class\n */\nexport class WavStreamPlayer {\n  /**\n   * Creates a new WavStreamPlayer instance\n   * @param {{sampleRate?: number}} options\n   * @returns {WavStreamPlayer}\n   */\n  constructor({ sampleRate = 44100 } = {}) {\n    this.scriptSrc = StreamProcessorSrc;\n    this.sampleRate = sampleRate;\n    this.context = null;\n    this.stream = null;\n    this.analyser = null;\n    this.trackSampleOffsets = {};\n    this.interruptedTrackIds = {};\n  }\n\n  /**\n   * Connects the audio context and enables output to speakers\n   * @returns {Promise<true>}\n   */\n  async connect() {\n    this.context = new AudioContext({ sampleRate: this.sampleRate });\n    if (this.context.state === 'suspended') {\n      await this.context.resume();\n    }\n    try {\n      await this.context.audioWorklet.addModule(this.scriptSrc);\n    } catch (e) {\n      console.error(e);\n      throw new Error(`Could not add audioWorklet module: ${this.scriptSrc}`);\n    }\n    const analyser = this.context.createAnalyser();\n    analyser.fftSize = 8192;\n    analyser.smoothingTimeConstant = 0.1;\n    this.analyser = analyser;\n    return true;\n  }\n\n  /**\n   * Gets the current frequency domain data from the playing track\n   * @param {\"frequency\"|\"music\"|\"voice\"} [analysisType]\n   * @param {number} [minDecibels] default -100\n   * @param {number} [maxDecibels] default -30\n   * @returns {import('./analysis/audio_analysis.js').AudioAnalysisOutputType}\n   */\n  getFrequencies(\n    analysisType = 'frequency',\n    minDecibels = -100,\n    maxDecibels = -30\n  ) {\n    if (!this.analyser) {\n      throw new Error('Not connected, please call .connect() first');\n    }\n    return AudioAnalysis.getFrequencies(\n      this.analyser,\n      this.sampleRate,\n      null,\n      analysisType,\n      minDecibels,\n      maxDecibels\n    );\n  }\n\n  /**\n   * Starts audio streaming\n   * @private\n   * @returns {Promise<true>}\n   */\n  _start() {\n    const streamNode = new AudioWorkletNode(this.context, 'stream_processor');\n    streamNode.connect(this.context.destination);\n    streamNode.port.onmessage = (e) => {\n      const { event } = e.data;\n      if (event === 'stop') {\n        streamNode.disconnect();\n        this.stream = null;\n      } else if (event === 'offset') {\n        const { requestId, trackId, offset } = e.data;\n        const currentTime = offset / this.sampleRate;\n        this.trackSampleOffsets[requestId] = { trackId, offset, currentTime };\n      }\n    };\n    this.analyser.disconnect();\n    streamNode.connect(this.analyser);\n    this.stream = streamNode;\n    return true;\n  }\n\n  /**\n   * Adds 16BitPCM data to the currently playing audio stream\n   * You can add chunks beyond the current play point and they will be queued for play\n   * @param {ArrayBuffer|Int16Array} arrayBuffer\n   * @param {string} [trackId]\n   * @returns {Int16Array}\n   */\n  add16BitPCM(arrayBuffer, trackId = 'default') {\n    if (typeof trackId !== 'string') {\n      throw new Error(`trackId must be a string`);\n    } else if (this.interruptedTrackIds[trackId]) {\n      return;\n    }\n    if (!this.stream) {\n      this._start();\n    }\n    let buffer;\n    if (arrayBuffer instanceof Int16Array) {\n      buffer = arrayBuffer;\n    } else if (arrayBuffer instanceof ArrayBuffer) {\n      buffer = new Int16Array(arrayBuffer);\n    } else {\n      throw new Error(`argument must be Int16Array or ArrayBuffer`);\n    }\n    this.stream.port.postMessage({ event: 'write', buffer, trackId });\n    return buffer;\n  }\n\n  /**\n   * Gets the offset (sample count) of the currently playing stream\n   * @param {boolean} [interrupt]\n   * @returns {{trackId: string|null, offset: number, currentTime: number}}\n   */\n  async getTrackSampleOffset(interrupt = false) {\n    if (!this.stream) {\n      return null;\n    }\n    const requestId = crypto.randomUUID();\n    this.stream.port.postMessage({\n      event: interrupt ? 'interrupt' : 'offset',\n      requestId,\n    });\n    let trackSampleOffset;\n    while (!trackSampleOffset) {\n      trackSampleOffset = this.trackSampleOffsets[requestId];\n      await new Promise((r) => setTimeout(() => r(), 1));\n    }\n    const { trackId } = trackSampleOffset;\n    if (interrupt && trackId) {\n      this.interruptedTrackIds[trackId] = true;\n    }\n    return trackSampleOffset;\n  }\n\n  /**\n   * Strips the current stream and returns the sample offset of the audio\n   * @param {boolean} [interrupt]\n   * @returns {{trackId: string|null, offset: number, currentTime: number}}\n   */\n  async interrupt() {\n    return this.getTrackSampleOffset(true);\n  }\n}\n\nglobalThis.WavStreamPlayer = WavStreamPlayer;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}